#include "effects/Effects.hps"

//-------------------------------------------------

/////////////////////////////////////////
// SHAKE
/////////////////////////////////////////

//-------------------------------------------------

/**
 * Makes the screen shake for a certain amount of time. Returns id to the current shaking.
 * If several calls to shake has been made the largest one is used.
 * 
 * @param afAmount The strength of the shake.
 * @param afTime The time it shakes at full intensity (fade in and fade out are added to this).
 * @param afFadeInTime The time before it reaches full strenght.
 * @param afFadeOutTime The time, after afTime is up, that it will take for the shake to reach zero strength.
 * @param avDirAmount The amount it will shake in each direction in camera space 
 * @param afFrequency Times per seconds the shake will change offset. 0=every update (ie max).
 **/
int Effect_Shake_Start(	float afAmount, float afTime, float afFadeInTime,float afFadeOutTime,
						const cVector3f &in avDirAmount=cVector3f(1,1,1), float afFrequency=0)
{
	iScrEffect_Shake@ pShake = cast<iScrEffect_Shake>(cLux_GetEffectHandler().GetEffect(eEffect_Shake));
	
	return pShake.Start(afAmount, afTime, afFadeInTime, afFadeOutTime, avDirAmount, afFrequency);	
}

/**
 * Fades out one or all shake instances.
 * 
 * @param alID The id of the shake (returned by Effect_Shake_Start). -1 = fade out all active shakes.
 * @param afFadeOutTime the time it takes to fade out.
 **/
void Effect_Shake_FadeOut(int alID, float afFadeOutTime)
{
	iScrEffect_Shake@ pShake = cast<iScrEffect_Shake>(cLux_GetEffectHandler().GetEffect(eEffect_Shake));
	
	pShake.FadeOut(alID, afFadeOutTime);	
}

/**
 * 
 * Sets an entity as the source of a shake instance. The shake instance will increase in strength as the player gets closer to the entity.
 * 
 * @param alID The id of the shake (returned by Effect_Shake_Start).
 * @param asSourceEntity entity to be used as source.
 * @param afMinDist distance to entity where the shake will be at its most powerful.
 * @param afMaxDist distance where shake will have faded out completely.
 * @param aEasingType the curve the strength of the shake will follow as you move further from the entity.
 **/
void Effect_Shake_SetSourceEntity(int alID, const tString &in asSourceEntity, float afMinDist, float afMaxDist, eEasing aEasingType = eEasing_CubicIn)
{
	iScrEffect_Shake@ pShake = cast<iScrEffect_Shake>(cLux_GetEffectHandler().GetEffect(eEffect_Shake));

	tID sourceID = cLux_GetCurrentMap().GetEntityIDByName(asSourceEntity, eLuxEntityType_LastEnum, "");
	
	pShake.SetSourceEntity(alID, sourceID, afMinDist, afMaxDist, aEasingType);	
}

//-------------------------------------------------

/**
 * 
 * Gets the current amount of shake (as in abs larges element in shake vector)
 * 
 **/
float Effect_Shake_GetCurrentShakeAmount()
{
	iScrEffect_Shake@ pShake = cast<iScrEffect_Shake>(cLux_GetEffectHandler().GetEffect(eEffect_Shake));
	
	return pShake.GetCurrentShakeAmount();
}

//-------------------------------------------------

void Effect_Shake_EnableAll(bool abState)
{
	cScript_SetGlobalVarBool("ShakesEnabled", abState);
}

//-------------------------------------------------

void Effect_VideoDistortion_EnableAll(bool abState)
{
	cScript_SetGlobalVarBool("DistortionEnabled", abState);
}

//-------------------------------------------------

/////////////////////////////////////////
// FADE
/////////////////////////////////////////

//-------------------------------------------------

void Effect_Fade_In(float afTime)
{	
	cLux_GetEffectHandler().FadeIn(afTime);
}

//-------------------------------------------------

void Effect_Fade_Out(float afTime)
{
	cLux_GetEffectHandler().FadeOut(afTime);
}

//-------------------------------------------------

bool Effect_Fade_IsFading()
{
	return cLux_GetEffectHandler().IsFading();
}

//-------------------------------------------------

float Effect_Fade_GetAlpha()
{
	return cLux_GetEffectHandler().GetFadeAlpha();
}

//-------------------------------------------------

/////////////////////////////////////////
// OBJECT GLOW
/////////////////////////////////////////

//-------------------------------------------------

/**
 * Adds a glow effect to the object to make it more visible to the player
 * Must be called from OnPostUpdate() every frame the glow should be visible 
 * 
 * @param apEntity entity to glow
 * @param afAlpha how much it should glow, [0, 1]
 * @param afY The position of the the glow.
 **/
void Effect_Glow_AddEntity(iLuxEntity@ apEntity, float afAlpha, float afY)
{	
	cLux_GetEffectHandler().AddGlowObject(apEntity, afAlpha, afY);
}

//-------------------------------------------------

/////////////////////////////////////////
// BLOOM
/////////////////////////////////////////

//-------------------------------------------------

/**
 * Sets if bloom should be active
 * Bloom is an effect that makes bright colors glow in a halo around the object
 * 
 * @param abX if bloom should be active
 **/
void Effect_Bloom_SetActive(bool abX)
{
	iScrEffect_ToneMapping@ pToneMap = cast<iScrEffect_ToneMapping>(cLux_GetEffectHandler().GetEffect(eEffect_ToneMapping));

	pToneMap.SetBloomActive(abX);
}

//-------------------------------------------------

/**
 * Changes the bright pass of the bloom over time
 * 
 * @param afBrightPass how bright a color has to be to be able to bloom, this should be a values between 0-1
 * @param afTime time to fade
 **/
void Effect_Bloom_FadeBrightPass(float afBrightPass, float afTime)
{
	iScrEffect_ToneMapping@ pToneMap = cast<iScrEffect_ToneMapping>(cLux_GetEffectHandler().GetEffect(eEffect_ToneMapping));

	pToneMap.FadeBrightPass(afBrightPass, afTime);
}

//-------------------------------------------------

/**
 * Changes the width of the bloom over time
 * 
 * @param afBloomWidth the width in pixels of the bloom halo, works best with a value between 32-512 pixels
 * @param afTime time to fade
 **/
void Effect_Bloom_FadeBloomWidth(float afBloomWidth, float afTime)
{
	iScrEffect_ToneMapping@ pToneMap = cast<iScrEffect_ToneMapping>(cLux_GetEffectHandler().GetEffect(eEffect_ToneMapping));

	pToneMap.FadeBloomWidth(afBloomWidth, afTime);
}

//-------------------------------------------------

/**
 * Changes the sharpness of the bloom over time
 * 
 * @param afBloomFalloff how sharp the bloom should be, higher = sharper, 0.5 default
 * @param afTime time to fade
 **/
void Effect_Bloom_FadeBloomFalloff(float afBloomFalloff, float afTime)
{
	iScrEffect_ToneMapping@ pToneMap = cast<iScrEffect_ToneMapping>(cLux_GetEffectHandler().GetEffect(eEffect_ToneMapping));

	pToneMap.FadeBloomFalloff(afBloomFalloff, afTime);
}

//-------------------------------------------------

/**
 * Changes the color of the bloom over time
 * 
 * @param (afR, afG, afB) the color to tint the bloom in
 * @param afTime time to fade
 **/
void Effect_Bloom_FadeBloomTint(float afR, float afG, float afB, float afTime)
{
	iScrEffect_ToneMapping@ pToneMap = cast<iScrEffect_ToneMapping>(cLux_GetEffectHandler().GetEffect(eEffect_ToneMapping));

	pToneMap.FadeBloomTint(afR, afG, afB, afTime);
}

//-------------------------------------------------

/////////////////////////////////////////
// FILM GRAIN
/////////////////////////////////////////

//-------------------------------------------------

/**
 * Sets if film grain should be active
 * Film Grain is an effect that applies animated noise to the image to remove banding and give life to it
 * 
 * @param abX if film grain should be active
 **/
void Effect_FilmGrain_SetActive(bool abX)
{
	iScrEffect_ToneMapping@ pToneMap = cast<iScrEffect_ToneMapping>(cLux_GetEffectHandler().GetEffect(eEffect_ToneMapping));

	pToneMap.SetFilmGrainActive(abX);
}

//-------------------------------------------------

/**
 * Changes the amount of noise applied to the screen over time
 * 
 * @param afIntensity the amount of noise applied to the screen
 * @param afTime time to fade in
 **/
void Effect_FilmGrain_FadeFilmGrainIntensity(float afIntensity, float afTime)
{
	iScrEffect_ToneMapping@ pToneMap = cast<iScrEffect_ToneMapping>(cLux_GetEffectHandler().GetEffect(eEffect_ToneMapping));

	pToneMap.FadeFilmGrainIntensity(afIntensity, afTime);
}

//-------------------------------------------------

/////////////////////////////////////////
// DEPTH OF FIELD
/////////////////////////////////////////

//-------------------------------------------------

/**
 * Starts an instance of depth of field and returns the id
 * 
 * @param afFocusStart near plane of the instance
 * @param afFocusEnd far plane of the instance
 * @param afFalloff how smooth the transition from sharp to blurr should be
 * @param afTime time to fade to this value
 **/
int Effect_DoF_Start(float afFocusStart, float afFocusEnd, float afFalloff, float afTime)
{
	iScrEffect_DepthOfField@ pDoF = cast<iScrEffect_DepthOfField>(cLux_GetEffectHandler().GetEffect(eEffect_DoF));
	
	return pDoF.Start(afFocusStart, afFocusEnd, afFalloff, afTime);
}

/**
 * Fade the start and end of the focus plane
 * 
 * @param alID id of the instance
 * @param afFocusStart near plane of the instance
 * @param afFocusEnd far plane of the instance
 * @param afTime time to fade to this value
 **/
void Effect_DoF_FadeFocus(int alID, float afFocusStart, float afFocusEnd, float afTime)
{
	iScrEffect_DepthOfField@ pDoF = cast<iScrEffect_DepthOfField>(cLux_GetEffectHandler().GetEffect(eEffect_DoF));

	pDoF.FadeFocus(alID, afFocusStart, afFocusEnd, afTime);
}

//-------------------------------------------------

/**
 * Fade the falloff of the instance
 * 
 * @param alID id of the instance
 * @param afFocusFalloff how smooth the transition from sharp to blurr should be
 * @param afTime time to fade in
 **/
void Effect_DoF_FadeFalloff(int alID, float afFocusFalloff, float afTime)
{
	iScrEffect_DepthOfField@ pDoF = cast<iScrEffect_DepthOfField>(cLux_GetEffectHandler().GetEffect(eEffect_DoF));

	pDoF.FadeFalloff(alID, afFocusFalloff, afTime);
}

//-------------------------------------------------

/**
 * Fade out the instance of depth of field, the instance is removed after fading out
 * 
 * @param alID id of the instance
 * @param afTime time to fade out
 **/
void Effect_DoF_FadeOut(int alID, float afTime)
{
	iScrEffect_DepthOfField@ pDoF = cast<iScrEffect_DepthOfField>(cLux_GetEffectHandler().GetEffect(eEffect_DoF));

	pDoF.FadeOut(alID, afTime);
}

//-------------------------------------------------

void Effect_DoF_Reset()
{
	iScrEffect_Interface@ pDoF = cLux_GetEffectHandler().GetEffect(eEffect_DoF);
	pDoF.Reset();
}

//-------------------------------------------------

/////////////////////////////////////////
// TONE MAPPING
/////////////////////////////////////////

/**
 * If srgb gamma should be used. Default is normal pow(x, 1 / gamma)
 * 
 * @param abX If srgb gamma correction should be used
 **/
void Effect_ToneMapping_UseSRGB(bool abX)
{
	iScrEffect_ToneMapping@ pToneMap = cast<iScrEffect_ToneMapping>(cLux_GetEffectHandler().GetEffect(eEffect_ToneMapping));

	pToneMap.SetSRGB(abX);
}

//-------------------------------------------------

/**
 * Changes the overall brightness of the image over time
 * 
 * @param afExposure how much extra light should be let though the lens, 0 is default
 * @param afTime time to fade in
 **/
void Effect_ToneMapping_FadeExposure(float afExposure, float afTime)
{
	iScrEffect_ToneMapping@ pToneMap = cast<iScrEffect_ToneMapping>(cLux_GetEffectHandler().GetEffect(eEffect_ToneMapping));

	pToneMap.FadeExposure(afExposure, afTime);
}

//-------------------------------------------------

/**
 * Get the current exposure value of the viewport
 * 
 * @return, current exposure
 **/
float Effect_ToneMapping_GetExposure()
{
	iScrEffect_ToneMapping@ pToneMap = cast<iScrEffect_ToneMapping>(cLux_GetEffectHandler().GetEffect(eEffect_ToneMapping));

	return pToneMap.GetExposure();
}

/**
 * Get the current exposure value of the viewport
 * 
 * @return, current brightness
 **/
float Effect_ToneMapping_GetExposureBrightness()
{
	iScrEffect_ToneMapping@ pToneMap = cast<iScrEffect_ToneMapping>(cLux_GetEffectHandler().GetEffect(eEffect_ToneMapping));

	return cMath_Pow(2.0, pToneMap.GetExposure());
}

//-------------------------------------------------

/**
 * Changes the white point of the tone mapper over time
 * Every color brighter then the white cut gets clamped to (1,1,1)
 * 
 * @param afWhiteCut the value of the white cut, every brighter color get set to white
 * @param afTime time to fade in
 **/
void Effect_ToneMapping_FadeWhiteCut(float afWhiteCut, float afTime)
{
	iScrEffect_ToneMapping@ pToneMap = cast<iScrEffect_ToneMapping>(cLux_GetEffectHandler().GetEffect(eEffect_ToneMapping));

	pToneMap.FadeWhiteCut(afWhiteCut, afTime);
}

//-------------------------------------------------

/**
 * Fades in a grading texture which changes the final color of the image
 * 
 * @param asTextureName name of the grading texture
 * @param afTime time to fade in
 **/
void Effect_ToneMapping_FadeGrading(tString asTextureName, float afTime)
{
	iScrEffect_ToneMapping@ pToneMap = cast<iScrEffect_ToneMapping>(cLux_GetEffectHandler().GetEffect(eEffect_ToneMapping));

	pToneMap.FadeGrading(asTextureName, afTime);
}

//-------------------------------------------------

/////////////////////////////////////////
// IMAGE TRAIL
/////////////////////////////////////////

//-------------------------------------------------

/**
 * Image trail blends the image of multiple previous frames over time, multiple instances can be active at the same time
 * The strongest instance of image trail will be used
 * 
 * @param afAmount how much of the previous frame should be blended, values from 0-inf, 0 = disabled
 * @param afFadeInTime how long it should take to fade to fade in
 * @param afStayTime how long it will stay before starting to fade out. If <0, then it stays for ever.
 * @param afFadeOutTime how long it will take to fade out
 * @return the id to this image trail instance
 **/
int Effect_ImageTrail_Start(float afAmount, float afFadeInTime, float afStayTime, float afFadeOutTime)
{
	iScrEffect_ImageTrail@ pTrail = cast<iScrEffect_ImageTrail>(cLux_GetEffectHandler().GetEffect(eEffect_ImageTrail));

	return pTrail.Start(afAmount, afFadeInTime, afStayTime, afFadeOutTime);
}

//-------------------------------------------------

/**
 * Image trail blends the image of multiple previous frames over time.
 * (in case Effect_ImageTrail_Start has also been used, the strongest instance of image trail will be used
 * 
 * @param afAmount how much of the previous frame should be blended, values from 0-inf, 0 = disabled
 **/
void Effect_ImageTrail_SetDirectAmount(float afAmount)
{
	iScrEffect_ImageTrail@ pTrail = cast<iScrEffect_ImageTrail>(cLux_GetEffectHandler().GetEffect(eEffect_ImageTrail));

	pTrail.SetDirectAmount(afAmount);
}

//-------------------------------------------------

/**
 * Fades out an active instance of image trail
 * 
 * @param alID id of the trail instance, returned by _Start
 * @param afFadeOutTime how long it will take to fade out
 **/
void Effect_ImageTrail_FadeOut(int alID, float afFadeOutTime)
{
	iScrEffect_ImageTrail@ pTrail = cast<iScrEffect_ImageTrail>(cLux_GetEffectHandler().GetEffect(eEffect_ImageTrail));

	pTrail.FadeOut(alID, afFadeOutTime);
}


//-------------------------------------------------

/**
 * Clears all effects
 * 
 **/
void Effect_ImageTrail_Clear()
{
	iScrEffect_ImageTrail@ pTrail = cast<iScrEffect_ImageTrail>(cLux_GetEffectHandler().GetEffect(eEffect_ImageTrail));

	pTrail.ClearAll();
}

//-------------------------------------------------

/////////////////////////////////////////
// CHROMATIC ABERRATION
/////////////////////////////////////////

//-------------------------------------------------

/**
 * @brief This is for TiMan's mod. Allow chromatic aberration effect or not.
 * @param abX true of false
 */
void Effect_ChromaticAberration_SetActive(bool abX)
{
	cScript_SetGlobalArgBool(0, abX);
	cScript_RunGlobalFunc("PlayerEnergyHandler", "", "_Global_SetChromaticAberrationActive");
}

//-------------------------------------------------

/**
 * Split the image into three images depending on color and makes rotation animation.
 * 
 * @param afDuration how long the effect should be active for, multiple instances can be active at the same time
 * @param afAmount how far the split should go in screen space, values between 0-0.2 look good
 * @param afRandomness the randomness of the splitting, if it should sway when splitting up and going back down, values larger than 1.0 will cause full rotation
 * @param avDirection an additional direction that the screen should move in when splitting, 0 = random
 **/
void Effect_ChromaticAberration_StartAnim(float afDuration, float afAmount, float afRandomness, cVector2f avDirection)
{
	iScrEffect_ChromaticAberration@ pEffect = cast<iScrEffect_ChromaticAberration>(cLux_GetEffectHandler().GetEffect(eEffect_ChromaticAberration));

	pEffect.StartAnim(afDuration, afAmount, afRandomness, avDirection);
}

//-------------------------------------------------

/**
 * Split the image into three images depending on color
 * 
 * @param afAmount The amount of the effect (how much seperation basically). Measured in part of screen. 0 - 0.2 looks good.
 * @param afRotation The rotation of the diffferent splits. 0 - 360
 * @param afHue Which use to split into, there is always a 120 seperation between each split, this sets. where to make these splits. 0 - 360
 * @param avOffset An extra offset.
 **/
void Effect_ChromaticAberration_SetDirect(float afAmount, float afRotation, float afHue=0, const cVector2f&in avOffset=cVector2f(0))
{
	iScrEffect_ChromaticAberration@ pEffect = cast<iScrEffect_ChromaticAberration>(cLux_GetEffectHandler().GetEffect(eEffect_ChromaticAberration));

	pEffect.SetDirect(afAmount, cMath_ToRad(afRotation), cMath_ToRad(afHue), avOffset);
}

//-------------------------------------------------

int Effect_ChromaticAberration_CreateInstance(float afAmount, float afRotation, float afHue=0, const cVector2f&in avOffset=cVector2f(0))
{
	iScrEffect_ChromaticAberration@ pEffect = cast<iScrEffect_ChromaticAberration>(cLux_GetEffectHandler().GetEffect(eEffect_ChromaticAberration));

	return pEffect.CreateInstance(afAmount, cMath_ToRad(afRotation), cMath_ToRad(afHue), avOffset);
}

//-------------------------------------------------

void Effect_ChromaticAberration_SetInstanceValues(int alID, float afAmount, float afRotation, float afHue=0, 
							const cVector2f&in avOffset=cVector2f_Zero)
{
	iScrEffect_ChromaticAberration@ pEffect = cast<iScrEffect_ChromaticAberration>(cLux_GetEffectHandler().GetEffect(eEffect_ChromaticAberration));

	pEffect.SetInstanceValues(alID, afAmount, cMath_ToRad(afRotation), cMath_ToRad(afHue), avOffset);
}

//-------------------------------------------------

void Effect_ChromaticAberration_DestroyInstance(int alID)
{
	iScrEffect_ChromaticAberration@ pEffect = cast<iScrEffect_ChromaticAberration>(cLux_GetEffectHandler().GetEffect(eEffect_ChromaticAberration));

	pEffect.DestroyInstance(alID);
}

//-------------------------------------------------

/////////////////////////////////////////
// FLASH
/////////////////////////////////////////

//-------------------------------------------------

/**
 * Fades exposure in and out to create a white flash effect.
 * 
 * @param afFadeIn time to fade in.
 * @param afWhite time to remain at the max exposure.
 * @param afFadeOut time to fade out.
 **/
void Effect_Flash_Start(float afFadeIn, float afWhite, float afFadeOut)
{
	iScrEffect_Flash@ pFlash = cast<iScrEffect_Flash>(cLux_GetEffectHandler().GetEffect(eEffect_Flash));

	pFlash.Start(afFadeIn, afWhite, afFadeOut);
}

//-------------------------------------------------

/////////////////////////////////////////
// SCREEN EFFECTS
/////////////////////////////////////////

//-------------------------------------------------

/**
 * Creates a images that shows up on the screen, it must be faded manually
 * Remember that these must work on both 4:3 and 16:9 aspect ratio 
 *
 * @param asMaterial material to use
 * @param avPosition position on the screen, values between [0,1]
 * @param avSize size of the texture
 * @return the id to this screen material
 **/
int Effect_Screen_Start(const tString &in asMaterial, cVector2f avPosition, cVector2f avSize)
{
	iScrEffect_Screen@ pScreen = cast<iScrEffect_Screen>(cLux_GetEffectHandler().GetEffect(eEffect_Screen));

	return pScreen.Start(asMaterial, avPosition, avSize);
}

/**
 * Creates a images that fade in and then out
 * Remember that these must work on both 4:3 and 16:9 aspect ratio 
 *
 * @param asMaterial material to use
 * @param avPosition position on the screen, values between [0,1]
 * @param avSize size of the texture
 * @param afTargetAlpha alpha it should stop fading at
 * @param afFadeInTime how fast it should fade in
 * @param afStayTime how long it should stay after fading in
 * @param afFadeOutTime how fast it should fade out again
 * @return the id to this screen material
 **/
int Effect_Screen_Start(const tString &in asMaterial, cVector2f avPosition, cVector2f avSize, float afTargetAlpha, float afFadeInTime, float afStayTime, float afFadeOutTime)
{
	iScrEffect_Screen@ pScreen = cast<iScrEffect_Screen>(cLux_GetEffectHandler().GetEffect(eEffect_Screen));

	return pScreen.Start(asMaterial, avPosition, avSize, afTargetAlpha, afFadeInTime, afStayTime, afFadeOutTime);
}

/**
 * Fades out a material
 *
 * @param alID id of the screen material
 * @param afFadeTime time to fade out over
 **/
void Effect_Screen_FadeOut(int alID, float afFadeTime)
{
	iScrEffect_Screen@ pScreen = cast<iScrEffect_Screen>(cLux_GetEffectHandler().GetEffect(eEffect_Screen));

	pScreen.FadeOut(alID, afFadeTime);
}

/**
 * Fades the liquid amount of a material, this is a variable used by the shader to determine wetness
 *
 * @param alID id of the screen material
 * @param afAmount liquid amount, value between [0,1]
 * @param afFadeTime time to fade over
 **/
void Effect_Screen_FadeLiquidAmount(int alID, float afAmount, float afFadeTime)
{
	iScrEffect_Screen@ pScreen = cast<iScrEffect_Screen>(cLux_GetEffectHandler().GetEffect(eEffect_Screen));

	pScreen.FadeLiquidAmount(alID, afAmount, afFadeTime);
}

/**
 * Fades the transparency of a material
 *
 * @param alID id of the screen material
 * @param afAlpha transparency of the material value between [0,1]
 * @param afFadeTime time to fade over
 **/
void Effect_Screen_FadeAlpha(int alID, float afAlpha, float afFadeTime)
{
	iScrEffect_Screen@ pScreen = cast<iScrEffect_Screen>(cLux_GetEffectHandler().GetEffect(eEffect_Screen));

	pScreen.FadeAlpha(alID, afAlpha, afFadeTime);
}

//-------------------------------------------------

/////////////////////////////////////////
// RADIAL BLUR
/////////////////////////////////////////

//-------------------------------------------------

/**
 * Directly sets the values of radial blur (but will blend with any instnace that has been started)
 *
 * @param afSize size of the blur, screen size, looks good 0.01-0.1
 * @param afStartDistance how far away from the center the blur should start
 * @param afAlpha how visible the blur is
 **/
void Effect_RadialBlur_SetDirect(float afSize, float afStartDistance, float afAlpha)
{
	iScrEffect_RadialBlur@ pEffect = cast<iScrEffect_RadialBlur>(cLux_GetEffectHandler().GetEffect(eEffect_RadialBlur));

	pEffect.SetDirect(afSize, afAlpha, afStartDistance);
}

/**
 * Starts a radial blur effect, will be active until Effect_RadialBlur_FadeOut() is called
 * Multiple instances of radial blur can be active at the same time
 *
 * @param afSize size of the blur, screen size, looks good 0.01-0.1
 * @param afAlpha how visible the blur is
 * @param afStartDistance how far away from the center the blur should start
 * @param afTime time to fade in
 * @return the id to this radial blur instance
 **/
int Effect_RadialBlur_Start(float afSize, float afAlpha, float afStartDistance, float afTime)
{
	iScrEffect_RadialBlur@ pEffect = cast<iScrEffect_RadialBlur>(cLux_GetEffectHandler().GetEffect(eEffect_RadialBlur));

	return pEffect.Start(afSize, afAlpha, afStartDistance, afTime);
}

/**
 * Changes the size of the blur of this instance
 *
 * @param alID id to the instance to change
 * @param afSize size of the blur
 * @param afTime fade time of the blur
 **/
void Effect_RadialBlur_FadeSize(int alID, float afSize, float afTime)
{
	iScrEffect_RadialBlur@ pEffect = cast<iScrEffect_RadialBlur>(cLux_GetEffectHandler().GetEffect(eEffect_RadialBlur));

	pEffect.FadeSize(alID, afSize, afTime);
}

/**
 * Changes how far away from the center to start blurring
 *
 * @param alID id to the instance to change
 * @param afDistance distance from center [0-1]
 * @param afTime fade time
 **/
void Effect_RadialBlur_FadeStartDistance(int alID, float afDistance, float afTime)
{
	iScrEffect_RadialBlur@ pEffect = cast<iScrEffect_RadialBlur>(cLux_GetEffectHandler().GetEffect(eEffect_RadialBlur));

	pEffect.FadeStartDistance(alID, afDistance, afTime);
}

/**
 * Changes how visible the instance should be
 *
 * @param alID id to the instance to change
 * @param afAlpha how visible it should be [0-1]
 * @param afTime fade time
 **/
void Effect_RadialBlur_FadeAlpha(int alID, float afAlpha, float afTime)
{
	iScrEffect_RadialBlur@ pEffect = cast<iScrEffect_RadialBlur>(cLux_GetEffectHandler().GetEffect(eEffect_RadialBlur));

	pEffect.FadeAlpha(alID, afAlpha, afTime);
}

/**
 * Fades out this instance and removes it. The ID is invalid after this has been called
 *
 * @param alID id to the instance to fade out
 * @param afTime fade time
 **/
void Effect_RadialBlur_FadeOut(int alID, float afTime)
{
	iScrEffect_RadialBlur@ pEffect = cast<iScrEffect_RadialBlur>(cLux_GetEffectHandler().GetEffect(eEffect_RadialBlur));

	pEffect.FadeOut(alID, afTime);
}

//-------------------------------------------------

/////////////////////////////////////////
// IMAGE FADE FX
/////////////////////////////////////////

//-------------------------------------------------

void Effect_ImageFadeFX_SetAmount(float afX)
{
	iScrEffect_ImageFadeFX@ pEffect = cast<iScrEffect_ImageFadeFX>(cLux_GetEffectHandler().GetEffect(eEffect_ImageFadeFX));

	pEffect.SetAmount(afX);
}

void Effect_ImageFadeFX_FadeAmount(float afAmount, float afTime)
{
	iScrEffect_ImageFadeFX@ pEffect = cast<iScrEffect_ImageFadeFX>(cLux_GetEffectHandler().GetEffect(eEffect_ImageFadeFX));

	pEffect.FadeAmount(afAmount, afTime);
}

void Effect_ImageFadeFX_SetTextures(const tString& in asFadeTexture, const tString& in asColorTexture, const tString& in asOffsetTexture)
{
	iScrEffect_ImageFadeFX@ pEffect = cast<iScrEffect_ImageFadeFX>(cLux_GetEffectHandler().GetEffect(eEffect_ImageFadeFX));

	pEffect.SetTextures(asFadeTexture, asColorTexture, asOffsetTexture);
}

//-------------------------------------------------


/////////////////////////////////////////
// VIDEO DISTORTION
/////////////////////////////////////////

//-------------------------------------------------

/**
 * Sets the amount of video distortion directly. (if there are instances in play, then the max amount will be used)
 *
 * @param afX The amount of the effect, 0 - 1 are valid values. (0 turns off)
 **/
void Effect_VideoDistortion_SetDirectAmount(float afX)
{
	iScrEffect_VideoDistortion@ pEffect = cast<iScrEffect_VideoDistortion>(cLux_GetEffectHandler().GetEffect(eEffect_VideoDistortion));

	pEffect.SetDirectAmount(afX);
}

//-------------------------------------------------

/**
 * Starts the video distortion effect. If many have been started the max amount is used. Returns ID to this instnace.
 *
 * @param afAmount The amount of effect, 0 - 1 are valid values. (0 turns off)
 * @param afTime The length the effect (after fade in) the effect should last. -1 means it lasts forever.
 * @param afFadeInTime The time it takes for the effect to fade in.
 * @param afFadeOutTime The time it takes for the effect to fade out.
 * @param afVolume Volume of gui sound (will override previous instances. Only one sound at a time)
 * 
 **/
int Effect_VideoDistortion_Start(float afAmount, float afTime, float afFadeInTime, float afFadeOutTime, float afVolume=1.0f)
{
	iScrEffect_VideoDistortion@ pEffect = cast<iScrEffect_VideoDistortion>(cLux_GetEffectHandler().GetEffect(eEffect_VideoDistortion));
	
	return pEffect.Start(afAmount, afTime, afFadeInTime, afFadeOutTime, afVolume);
}

//-------------------------------------------------

/**
 * Fades out a video distortion effect instance. 
 *
 * @param alID id to the instance to fade out. If -1, all instances will be faded.
 * @param afFadeOutTime The time it takes for the effect to fade out.
 **/
void Effect_VideoDistortion_FadeOut(int alID,float afFadeOutTime)
{
	iScrEffect_VideoDistortion@ pEffect = cast<iScrEffect_VideoDistortion>(cLux_GetEffectHandler().GetEffect(eEffect_VideoDistortion));
	
	pEffect.FadeOut(alID, afFadeOutTime);
}

//-------------------------------------------------

/**
 * Sets the max amount of an instnace (basically changes the amount)
 *
 * @param alID id to the instance to fade out
 * @param afMaxAmount The new max amount to be used, 0 -1 are valid values.
 **/
void Effect_VideoDistortion_SetMaxAmount(int alID, float afMaxAmount)
{
	iScrEffect_VideoDistortion@ pEffect = cast<iScrEffect_VideoDistortion>(cLux_GetEffectHandler().GetEffect(eEffect_VideoDistortion));
	
	pEffect.SetMaxAmount(alID, afMaxAmount);
}

//-------------------------------------------------
/**
 * Get the current amount of the distortion
 **/
float  Effect_VideoDistortion_GetAmount()
{
	iScrEffect_VideoDistortion@ pEffect = cast<iScrEffect_VideoDistortion>(cLux_GetEffectHandler().GetEffect(eEffect_VideoDistortion));
	
	return pEffect.GetAmount();
}

//-------------------------------------------------
/**
 * Get the current effect amount of the distortion (the one that is sent to the post effect)
 **/
float  Effect_VideoDistortion_GetEffectAmount()
{
	iScrEffect_VideoDistortion@ pEffect = cast<iScrEffect_VideoDistortion>(cLux_GetEffectHandler().GetEffect(eEffect_VideoDistortion));
	
	return pEffect.GetEffectAmount();
}

//-------------------------------------------------

/**
 * Set if video distortion sounds should be disabled.
 **/
void  Effect_VideoDistortion_SetSoundEffectsDisabled(bool abX)
{
	iScrEffect_VideoDistortion@ pEffect = cast<iScrEffect_VideoDistortion>(cLux_GetEffectHandler().GetEffect(eEffect_VideoDistortion));
	
	pEffect.SetSoundEffectsDisabled(abX);
}


//-------------------------------------------------

/////////////////////////////////////////
// TIME GLITCH
/////////////////////////////////////////

//-------------------------------------------------

/**
 * Starts an effect that makes physics and visual jump forward in time.
 *
 * @param afTimeAdvancement The amount of time physics and visuals should advance.
 * @param afPlayFastSoundTime How long the sounds should run sped up. (sound freq depends on the time advancement + this time)
 * @param afShakeAmount How much the screen should shake.
 * @param abPlayEffectSound If an effect sound should play.
 * @param afSoundEffectVolume Volume of the sound being played.
 **/
void  Effect_TimeGlitch_Start(float afTimeAdvancement, float afPlayFastSoundTime, float afShakeAmount, bool abPlayEffectSound, float afSoundEffectVolume=1.0f)
{
	iScrEffect_TimeGlitch@ pEffect = cast<iScrEffect_TimeGlitch>(cLux_GetEffectHandler().GetEffect(eEffect_TimeGlitch));
	
	pEffect.Start(afTimeAdvancement, afPlayFastSoundTime,afShakeAmount, abPlayEffectSound, afSoundEffectVolume);
}

//-------------------------------------------------

/////////////////////////////////////////
//SWAY
/////////////////////////////////////////

//-------------------------------------------------

/**
 * @param afSize max X size of sway
 * @param afTime fade in time
 * @param afRate how many sways per second
 * @param afAngle sway will be around a line on XZ plane - this sets the y-axis rotation of it (degrees : 0 = along X axis)
 * @param afInitialAmount how big is the initial sway size? (0.0f - 1.0f) If negative, has no effect.
 * @param afYMul multiplier of afSwaySize for y
 * @param afDecay how fast the swaying dies away (1.0f = never dies)
 * @param afMoveFactor how much of the player's move speed to factor in
 */
void Effect_Sway_FadeIn(float afSize, float afTime, float afRate, float afAngle, float afInitialAmount=-1.0f, 
	float afYMul=0.25f, float afDecay=0.995f, float afMoveFactor = 0.4f)
{
	iScrEffect_Sway@ pEffect = cast<iScrEffect_Sway>(cLux_GetEffectHandler().GetEffect(eEffect_Sway));
	pEffect.FadeIn(afSize, afTime, afRate, afAngle, afInitialAmount, afYMul, afDecay, afMoveFactor);
}

//-------------------------------------------------

/**
 * @param afSize max X size of sway
 * @param afRate how many sways per second
 * @param afAngle sway will be around a line on XZ plane - this sets the y-axis rotation of it (degrees : 0 = along X axis)
 * @param afInitialAmount how big is the initial sway size? (0.0f - 1.0f). If negative, has no effect.
 * @param afYMul multiplier of afSwaySize for y
 * @param afDecay how fast the swaying dies away (1.0f = never dies)
 * @param afMoveFactor how much of the player's move speed to factor in
 */
void Effect_Sway_SetDirect(float afSize, float afRate, float afAngle, float afInitialAmount=-1.0f, 
	float afYMul=0.25f, float afDecay=0.995f, float afMoveFactor = 0.4f)
{
	iScrEffect_Sway@ pEffect = cast<iScrEffect_Sway>(cLux_GetEffectHandler().GetEffect(eEffect_Sway));
	pEffect.SetDirect(afSize, afRate, afAngle, afInitialAmount, afYMul, afDecay, afMoveFactor);
}

//-------------------------------------------------

/**
 * @param afTime How long it takes to fade out.
 */
void Effect_Sway_FadeOut(float afTime)
{
	iScrEffect_Sway@ pEffect = cast<iScrEffect_Sway>(cLux_GetEffectHandler().GetEffect(eEffect_Sway));
	pEffect.FadeOut(afTime);
}

//-------------------------------------------------

void Effect_Sway_Stop()
{
	iScrEffect_Sway@ pEffect = cast<iScrEffect_Sway>(cLux_GetEffectHandler().GetEffect(eEffect_Sway));
	pEffect.Stop();
}

//-------------------------------------------------

cVector3f Effect_Sway_GetOffset()
{
	iScrEffect_Sway@ pEffect = cast<iScrEffect_Sway>(cLux_GetEffectHandler().GetEffect(eEffect_Sway));
	return pEffect.GetOffset();
}

//-------------------------------------------------

/////////////////////////////////////////
// GAMEPAD
/////////////////////////////////////////

//-------------------------------------------------

/**
 * Start a gamepad rumble
 * @param afAmount strength of the rumble, between 0-1
 * @param afTime duration of the rumble
 * @param afFadeInTime fade time in the start
 * @param afFadeOutTime fade time at the end
 * @return id of the effect instance
 */
int Effect_Rumble_Start(float afAmount, float afTime, float afFadeInTime = 0,float afFadeOutTime = 0)
{
	iScrEffect_Gamepad@ pEffect = cast<iScrEffect_Gamepad>(cLux_GetEffectHandler().GetEffect(eEffect_Gamepad));
	return pEffect.StartRumble(afAmount, afTime, afFadeInTime,afFadeOutTime);
}

/**
 * Fade the gamepad color (the backlight of the ps4 controller)
 * @param aColor color of the light
 * @param afTime time to fade over
 * @return id of the effect instance
 */
int Effect_GamepadColor_Fade(cColor aColor, float afTime)
{
	iScrEffect_Gamepad@ pEffect = cast<iScrEffect_Gamepad>(cLux_GetEffectHandler().GetEffect(eEffect_Gamepad));
	return pEffect.StartColorFade(aColor, afTime);
}

/**
 * Stops the rumble from this id
 * @param alID id for the rumble instance, -1 to stop all
 */
void Effect_Rumble_Stop(int alID)
{
	iScrEffect_Gamepad@ pEffect = cast<iScrEffect_Gamepad>(cLux_GetEffectHandler().GetEffect(eEffect_Gamepad));
	pEffect.StopRumble(alID);
}

/**
 * Sets a multiplier for how much rumble should be generated from screenshake.
 * 
 * @param afX multiplier to set. 1 is default.
 */
void Effect_Rumble_SetScreenShakeMul(float afX)
{
	iScrEffect_Gamepad@ pEffect = cast<iScrEffect_Gamepad>(cLux_GetEffectHandler().GetEffect(eEffect_Gamepad));
	pEffect.SetShakeRumbleMul(afX);
}

/**
 * Stops the color fade from this id
 * @param alID id of the color fade instance, -1 to stop all
 */
void Effect_GamepadColor_Stop(int alID)
{
	iScrEffect_Gamepad@ pEffect = cast<iScrEffect_Gamepad>(cLux_GetEffectHandler().GetEffect(eEffect_Gamepad));
	pEffect.StopColorFade(alID);
}


