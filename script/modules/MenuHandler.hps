#include "interfaces/UserModule_Interface.hps"
#include "modules/ModuleInterfaces.hps"
#include "base/InputHandler_Types.hps"
#include "helpers/helper_imgui_options.hps"
#include "helpers/helper_imgui.hps"
#include "helpers/helper_game.hps"
#include "helpers/helper_audio.hps"

//---------------------------------------------------

enum eMainMenuGroup
{
	eMainMenuGroup_Main,
	eMainMenuGroup_StartGame,
	eMainMenuGroup_LoadGame,
	eMainMenuGroup_Options,
	eMainMenuGroup_Options_Audio,
	eMainMenuGroup_Options_Video,
	eMainMenuGroup_Options_Video_Display,
	eMainMenuGroup_Options_Video_PostEffect,
	eMainMenuGroup_Options_Video_World,
	eMainMenuGroup_Options_Video_Gamma,
	eMainMenuGroup_Options_Input,
	eMainMenuGroup_Options_Input_Keybind,
	eMainMenuGroup_Options_Input_Mouse,
	eMainMenuGroup_Options_Input_Gamepad,
	eMainMenuGroup_Options_Input_GamepadMapping,
	eMainMenuGroup_Options_Gameplay,
	eMainMenuGroup_LastEnum,
}

enum eGraphicSettings
{
	eGraphicSettings_Low,
	eGraphicSettings_Medium,
	eGraphicSettings_High,
	eGraphicSettings_LastEnum,
}


//-----------------------------------------

//-------------------------------------------------------------//
// Data for menu, values based on 1280x720 resolution
//-------------------------------------------------------------//

const cVector2f kMainMenuButtonPos = cVector2f(136, 275);
const cVector2f kTitlePos = cVector2f(100, 67);
const cVector2f kTitleSize = cVector2f(4 * 173, 173);
const cColor kMainMenuButtonBgColor = cColor(69.0 / 255.0, 139.0 / 255.0, 139.0 / 255.0, 1);

//-----------------------------------------

const cVector2f kOptionsBgPos = cVector2f(100, 260);
const cVector2f kOptionsBgSize = cVector2f(680, 255);
const cVector2f kOptionsAudioBgSize = cVector2f(680, 220);
const cVector2f kOptionsVideoBgSize = cVector2f(680, 295);
const cVector2f kOptionsGameplayBgSize = cVector2f(680, 255);
const cVector2f kOptionsGameplayPS4BgSize = cVector2f(680, 145);
const cVector2f kLoadWindowBgSize = cVector2f(680, 370);
const cVector2f kOptionsVideoPostEffectBgSize = cVector2f(680, 220);
const cVector2f kOptionsVideoWorldBgSize = cVector2f(680, 295);
const cVector2f kOptionsVideoDisplayBgSize = cVector2f(680, 335);
const cVector2f kOptionsVideoGammaBgSize = cVector2f(680, 140);
const cVector2f kOptionsBgBorderSize = cVector2f(680, 42.5);
const cVector2f kInputBgSize = cVector2f(680, 220);
const cVector2f kInputGamepadBgSize = cVector2f(680, 258);
const cVector2f kInputPS4BgSize = cVector2f(680, 220);
const cVector2f kKeybindWindowBgSize = cVector2f(680, 380);
const cVector2f kOptionsMappingBgSize = cVector2f(820, 370);

const cVector2f kGammaBgSize = cVector2f(680, 220);

const cVector2f kOptionMenu_KeybindBgPos = cVector2f(350, 335);
const cVector2f kOptionMenu_KeybindBgSize = cVector2f(550, 35);
const cVector2f kOptionMenu_KeybindBgBorderSize = cVector2f(550, 42.5);
const cVector2f kOptionMenu_PressXPos = cVector2f(250, 345);

//-----------------------------------------

const cVector2f kSaveSlotSpacing = cVector2f(175, 0);
const cVector2f kSaveSlotPos = cVector2f(0, 275);

//-----------------------------------------

const cVector2f kLoadBgPos = cVector2f(110, 270);
const cVector2f kLoadBgSize = cVector2f(623, 305);
const cVector2f kLoadScrollPos = cVector2f(718, 275);
const cVector2f kLoadScrollSize = cVector2f(10, 295);
const float kLoadSpacing = 30;

//-----------------------------------------

const cVector2f kKeybindBgPos = cVector2f(110, 270);
const cVector2f kKeybindBgSize = cVector2f(623, 275);
const cVector2f kKeybindScrollPos = cVector2f(718, 275);
const cVector2f kKeybindScrollSize = cVector2f(10, 265);
const float kKeybindSpacing = 30;

//-----------------------------------------

const cVector2f kMappingPos = cVector2f(170, 260);
const cVector2f kMappingSize = cVector2f(640, 320);

const cVector2f kMappingArrowPosRight = cVector2f(130, 400);
const cVector2f kMappingArrowPosLeft = cVector2f(180+640+30, 400);
const cVector2f kMappingArrowSize = cVector2f(32, 64);
const cVector2f kMappingButtonPosRight = cVector2f(-1024+180, 260);
const cVector2f kMappingButtonPosLeft = cVector2f(180+680, 260);
const cVector2f kMappingButtonSize = cVector2f(1024, 320);

//-----------------------------------------

float gfNewGameFadeOutTime=4;

//-----------------------------------------

const cColor kSelectedColor = cColor(1.0 / 255.0, 1);
const cColor kDeselectedColor = cColor(1, 1);
const cColor kDisabledColor = cColor(58.0 / 255.0, 1);

//-----------------------------------------

class cBindableAction
{
	cBindableAction(){}
	cBindableAction(tString asAction, bool abAnalog = false)
	{
		msAction = asAction;
		mbAnalog = abAnalog;
	}

	tString msAction;
	bool mbAnalog;
};

//-----------------------------------------

class cImGuiParticleEmitter
{
	cImGuiParticleEmitter()
	{
		mColorStartMin = cColor(1,1);
		mColorStartMax = cColor(1,0);
		mColorMulStart = cColor(1,1);
		mColorMulMiddle = cColor(1,1);
		mColorMulEnd = cColor(1,1);
	}
	array<cImGuiGfx> mvGfx;
	cVector3f mvMin = cVector3f(0,0,0);
	cVector3f mvMax = cVector3f(0,0,0);
	cVector3f mvVelocityMin = cVector3f(0,0,0);
	cVector3f mvVelocityMax = cVector3f(0,0,0);
	
	float mfSizeMin = 1.0f;
	float mfSizeMax = 1.0f;
	
	uint mlMaxParticles = 10;
	float mfParticlesPerSec = 10.0f;
	float mfNewParticleTime = 0.0f;
	
	float mfMinLife = 10.0f;
	float mfMaxLife = 10.0f;
	
	cColor mColorStartMin = cColor(1,1);
	cColor mColorStartMax = cColor(1,1);
	
	cColor mColorMulStart = cColor(1,1);
	cColor mColorMulMiddle = cColor(1,1);
	cColor mColorMulEnd = cColor(1,1);
	float mfColorMulMiddleStartTime = 0.25f;
	float mfColorMulEndStartTime = 0.75f;
	
	//bool mbDebug = false;
	
	//------------------------------------------------------
	
	array<uint>			mvParticleGfxIndices;
	array<float>		mvParticleLifeValues;
	array<float>		mvParticleLifeStepMuls;
	array<cVector3f>	mvParticlePositions;
	array<cVector3f>	mvParticleVelocities;
	array<float>		mvParticleSizes;
	array<cColor>		mvParticleStartColors;
	array<cColor>		mvParticleColors;
	
	//------------------------------------------------------
	
	void Update(float afTimeStep)
	{
		mfNewParticleTime -= afTimeStep;
		
		if(mfNewParticleTime<=0.0f && mvParticleLifeValues.length()<mlMaxParticles)
		{
			//uint lGfxIndex = cMath_RandRectl(0, mvGfx.length()-1);
			uint lGfxIndex = 0;
			mvParticleGfxIndices.insertLast(lGfxIndex);
			
			float fLife = cMath_RandRectf(mfMinLife, mfMaxLife);
			mvParticleLifeValues.insertLast(0.0f);
			mvParticleLifeStepMuls.insertLast(1.0f/fLife);
			
			cVector3f vStartPos = cMath_RandRectVector3f(mvMin, mvMax);
			cVector3f vStartVel = cMath_RandRectVector3f(mvVelocityMin, mvVelocityMax);
			
			mvParticlePositions.insertLast(vStartPos);
			mvParticleVelocities.insertLast(vStartVel);
			mvParticleSizes.insertLast(cMath_RandRectf(mfSizeMin, mfSizeMax));
			
			//if(mbDebug) cLux_AddDebugMessage("Particle start pos: " + vStartPos);
			
			float fColorT = cMath_RandRectf(0.0f, 1.0f);
			cColor colStart = mColorStartMin*(1-fColorT) + mColorStartMax*fColorT;
			mvParticleStartColors.insertLast(colStart);
			mvParticleColors.insertLast(colStart*mColorMulStart);
			
			mfNewParticleTime = 1.0f/mfParticlesPerSec;
		}
		
		array<int> vParticlesToRemove;
		for(int i=0; i<mvParticleLifeValues.length(); ++i)
		{
			if(ParticleIsDead(i))
			{
				vParticlesToRemove.insertLast(i);
				continue;
			}
			
			// Update particle
			float fLife = mvParticleLifeValues[i] + afTimeStep*mvParticleLifeStepMuls[i];
			
			mvParticleLifeValues[i]		= fLife;
			mvParticlePositions[i]		+= mvParticleVelocities[i]*afTimeStep;
			
			cColor col = mvParticleColors[i];
			cColor startCol = mvParticleStartColors[i];
			
			if(fLife<mfColorMulMiddleStartTime)
			{
				float fT = fLife/mfColorMulMiddleStartTime;
				
				col = startCol * mColorMulStart * (1.0f-fT) + 
							startCol * mColorMulMiddle * fT;
			}
			else if(fLife < mfColorMulEndStartTime)
			{
				col = startCol * mColorMulMiddle;
			}
			else
			{
				float fT = (fLife-mfColorMulEndStartTime)/(1.0f-mfColorMulEndStartTime);
											
				col = startCol * mColorMulMiddle * (1.0f-fT) + 
							startCol * mColorMulEnd * fT;
			}
			
			mvParticleColors[i] = col;
			
		}
		for(int i=0; i<vParticlesToRemove.length(); ++i)
		{
			int lParticleToRemoveIndex = vParticlesToRemove[i];
			
			mvParticleGfxIndices.removeAt(lParticleToRemoveIndex);
			mvParticleLifeValues.removeAt(lParticleToRemoveIndex);
			mvParticleLifeStepMuls.removeAt(lParticleToRemoveIndex);
			mvParticlePositions.removeAt(lParticleToRemoveIndex);
			mvParticleVelocities.removeAt(lParticleToRemoveIndex);
			mvParticleSizes.removeAt(lParticleToRemoveIndex);
			mvParticleColors.removeAt(lParticleToRemoveIndex);
			mvParticleStartColors.removeAt(lParticleToRemoveIndex);
		}
	}
	
	//------------------------------------------------------
	
	void Draw(float afTimeStep)
	{
		Update(afTimeStep);
		
		if(mvGfx.length()==0)
			return;
		
		array<cVector2f> vParticleSizes;
		for(int i=0; i<mvGfx.length(); ++i)
			vParticleSizes.insertLast(GetUsedGfxSize(mvGfx[i], -1));
		
		ImGui_SetAlignment(eImGuiAlign_CenterCenter);
		
		for(int i=0; i<mvParticleLifeValues.length(); ++i)
		{
			uint lGfxIndex = mvParticleGfxIndices[i];
			if(lGfxIndex>=mvGfx.length()) continue;
			
			ImGui_DrawGfx(mvGfx[lGfxIndex], 
						  mvParticlePositions[i], 
						  vParticleSizes[lGfxIndex]*mvParticleSizes[i], 
						  mvParticleColors[i]);
		}
		
		ImGui_SetAlignment(eImGuiAlign_TopLeft);
	}
	
	//------------------------------------------------------
	
	bool ParticleIsDead(int alIdx)
	{
		return mvParticleLifeValues[alIdx]>=1.0f;
	}
	
	//------------------------------------------------------
};

//-----------------------------------------

/////////////////////////////////////////
// Last on SOMA Screen
class cLastOnSomaScreen
{
	cLastOnSomaScreen()
	{
		CleanUp();
	}
	
	void LoadingStarted()
	{
		mbLoading_Started = true;
	}
	void Start(const tString &in asEntry)
	{
		if(IsActive()) return;
		
		msEntry = asEntry;
		if(msEntry.length()>0)
		{
			msText = cLux_Translate("LastOnSomaText", asEntry);
			if(msText.length()==0)
			{
				msEntry = "";
			}
			else
			{
				@mpScriptImGui = cLux_CreateScriptImGui("LastOnSoma", true);
				
				cImGuiGfx defPointer();
				defPointer.mColor = cColor(0.0f,0.0f);
				
				mpScriptImGui.mpImGui.SetDefaultMouse(defPointer);
				mpScriptImGui.mpImGui.SetDefaultFont(cImGuiFont("default_small.fnt", cVector2f(17) ));
				mpScriptImGui.mpImGui.SetShowMouse(false);
				
				mbFontSizeNeedsAdjust = true;
				mfFontHeight = 26.0f;
									
				LoadScreen_SetForceBackground(false);
				LoadScreen_SetUseSmallIcon(true);
				
				mpScriptImGui.mpImGui.AddTimer("Enable", 0.5f);
			}
		}
		
		if(IsActive()==false)
		{
			cLux_GetSaveHandler().ContinueLoading(true);
					
			LoadScreen_SetForceBackground(false);
			LoadScreen_SetUseSmallIcon(false);
			
			CleanUp();
		}
	}
	
	void CleanUp()
	{
		msText = "";
		@mpScriptImGui = null;
		
		mbLoading_Started = false;
		mbLoading_LoadHeaderDone = false;
		mbLoading_LoadGameDone = false;
		mbLoading_LoadScreenHidden = false;
		mbDismiss = false;
	}
	
	bool IsActive()
	{
		return mpScriptImGui !is null;
	}
	
	void Update(float afTimeStep)
	{
		if(mbLoading_Started==false)
			return;
			
		if(mbLoading_LoadHeaderDone==false)
		{
			mbLoading_LoadHeaderDone = cLux_GetSaveHandler().IsDoneLoadingHeader();
			if(mbLoading_LoadHeaderDone)
			{
				Start(cScript_GetGlobalVarString("LastOnSomaText"));
			}
		}
		
		if(IsActive()==false) return;
		
		cImGui @mpImGui = mpScriptImGui.mpImGui;
		
		////////////////////////////////////////////
		// So timers and stuff work
		mpImGui.Begin(afTimeStep);
		{
			////////////////////////////////////////
			// Check flags
			if(mbLoading_LoadGameDone==false)
			{
				mbLoading_LoadGameDone = cLux_GetSaveHandler().IsDoneLoadingSavedGame();
				
				if(mbLoading_LoadGameDone)
				{
					//cLux_AddDebugMessage("Saved game is done loading - waiting for loadscreen to go");
					
					//cLux_SetGamePaused(true);
				}
			}
			else if(mbLoading_LoadScreenHidden==false)
			{
				mbLoading_LoadScreenHidden = LoadScreen_IsVisible()==false;
								
				if(mbLoading_LoadScreenHidden)
				{
					//cLux_AddDebugMessage("Loadscreen gone - prompting to continue");
					
					mpImGui.SetStateFloat("PromptAlpha", 0.0f);
					mpImGui.FadeStateFloat("PromptAlpha", 1.0f, 0.5f);
				}					
			}
			else if(mbDismiss==false)
			{
				tString sKeyPress = cLux_GetInputHandler().GetLatestKeyPressed();
				if(sKeyPress.length()!=0)
				{
					mbDismiss = true;
					
					//cLux_AddDebugMessage("Dismissing");
					
					// Start fadeout
					mpImGui.FadeStateFloat("Alpha", 0.0, 0.25f);
					
					cLux_GetSaveHandler().StartLoadedGame();
					//cLux_SetGamePaused(false);
					
					cSoundEntry @pEntry = @cSound_GetEntry("loadscreen_background");
					if(pEntry !is null)
						pEntry.FadeOut(1.0f/3.0f);
				}
			}
			
			////////////////////////////////////
			// Check timers
			if(mpImGui.TimerOver("Enable"))
			{
				mpImGui.SetStateFloat("Alpha", 0.0f);
				mpImGui.FadeStateFloat("Alpha", 1.0f, 1.0f);
				Music_StopAll(2.0f);
                //Sound_Stop("MenuBGNoise",2.0f);
				cSound_PlayGuiStream("loadscreen_background", true, 0.15f, cVector3f(0,0,0), eSoundEntryType_Safe);
				//cSound_GetEntry("loadscreen_background").FadeIn(0.15f, 1.0f/3.0f);
				//Music_PlayExt("loadscreen_background", true, 0.15f, 1.0f, 3.0f, 0.0f, eMusicPrio_BgAmb, true);
			}
			
			/////////////////////////////////////
			// Check fadings
			if(mpImGui.FadeOver("Alpha"))
			{
				if(mbDismiss)
				{
					CleanUp();
					return;
				}
				else
				{
					cLux_GetSaveHandler().ContinueLoading(false);
				}
			}
			
			/////////////////////////////////////////
			// Draw the screen
			
			// Bottom layer : black, covering the whole screen
			cImGuiGfx gfxBlack;
			gfxBlack.mColor = cColor(0,1);
			mpImGui.DoImage(gfxBlack, cLux_GetHudVirtualStartPos()+cVector3f(0,0,10.0f), cLux_GetHudVirtualSize());
			
			// Set up group (will only take center screen if we are on a multiscreen setup
			mpImGui.GroupBegin(cLux_GetHudVirtualCenterScreenStartPos(), cLux_GetHudVirtualCenterScreenSize(), true);
			{
				float fZ = 415.0f;
				float fBGZ = 401.15f;   // 400.9f is LoadHandler black bg, 401.1f is whatever and 401.5f is brain icon
				
				float fAlpha = mpImGui.GetStateFloat("Alpha");
								
				mpImGui.SetModColorMul(cColor(1,fAlpha));
				
				// Bottom layer overlay: loading screen background
				cImGuiGfx gfxBG("loadscreen/backdrop.dds", eImGuiGfx_Texture);
				cVector2f vGfxBGSize = GetRatioCorrectSizeByNrmWidth(gfxBG, 1.0f);
				
				gfxBG.mColor = cColor(0.6f, 1.0f);
				mpImGui.SetAlignment(eImGuiAlign_CenterCenter);
				mpImGui.DoImage(gfxBG, NrmPos(0.5f, 0.5f, fBGZ), vGfxBGSize);
				
				// Last on SOMA screenshot
				cImGuiGfx gfxScreenshot(msEntry, eImGuiGfx_Texture);
				cVector3f vGfxScreenshotPos = NrmPos(0.25f, 1.0f/7.0f, fZ);
				cVector2f vGfxScreenshotSize = GetRatioCorrectSizeByNrmWidth(gfxScreenshot, 0.5f);
				
				mpImGui.SetAlignment(eImGuiAlign_TopLeft);
				mpImGui.DoImage(gfxScreenshot, vGfxScreenshotPos, vGfxScreenshotSize);
				
				// Set loading bar position
				cVector3f vLoadingBarPos = vGfxScreenshotPos;
				vLoadingBarPos.x += cLux_GetHudVirtualCenterScreenStartPos().x;
				cLux_LoadScreenSetBarPosAndSize(cVector2f(vLoadingBarPos.x, vLoadingBarPos.y + vGfxScreenshotSize.y - 4.2f), cVector2f(vGfxScreenshotSize.x, 4.2f));

				cVector3f vLinePos = vGfxScreenshotPos;
				vLinePos.y += vGfxScreenshotSize.y + 15.0f;
				
				// Text data and setup
				cImGuiTextFrameData textFrameData;
				textFrameData.mbUseBackgroundGfx = false;
				textFrameData.mFont.SetFile("sansation_medium.fnt");
				textFrameData.mFont.mvSize = cVector2f(mfFontHeight);
				textFrameData.mFont.mColor = cColor(1,1);
				
				cVector3f vTextFramePos = vLinePos + cVector3f(15.0f,0,0);
				cVector2f vTextFrameSize(vGfxScreenshotPos.x + vGfxScreenshotSize.x - vTextFramePos.x, NrmSize(0.0f, 0.95f).y-vLinePos.y);
				
				if(mbFontSizeNeedsAdjust)
				{
					mbFontSizeNeedsAdjust = false;
					
					array<tWString> vLines;
					GetFontWordWrapRowsW(textFrameData.mFont, 1.0f, msText, vTextFrameSize.x, vLines);
					
					lNumMaxLines = cMath_Abs(vTextFrameSize.y/(mfFontHeight));
					lNumLinesInText = vLines.length();
					
					if(lNumLinesInText>lNumMaxLines)
					{
						float fHeightIntervalStart = 0.0f;
						float fHeightIntervalEnd = mfFontHeight;
						float fHeightIntervalMid;
												
						while(lNumLinesInText!=lNumMaxLines)
						{
							fHeightIntervalMid = (fHeightIntervalStart+fHeightIntervalEnd)*0.5f;
							mfFontHeight = fHeightIntervalMid;
							
							textFrameData.mFont.mvSize = cVector2f(mfFontHeight);
							
							GetFontWordWrapRowsW(textFrameData.mFont, 1.0f, msText, vTextFrameSize.x, vLines);
						
							lNumMaxLines = cMath_Abs(vTextFrameSize.y/(mfFontHeight));
							lNumLinesInText = vLines.length();
							
							if(lNumLinesInText<lNumMaxLines)
								fHeightIntervalStart = fHeightIntervalMid;
							else
								fHeightIntervalEnd = fHeightIntervalMid;
						}
					}
				}
				
				float fSeparation = 30.0f;
				float fLineHeight = vTextFrameSize.y*0.65f;
				
				// Vertical line
				mpImGui.SetAlignment(eImGuiAlign_TopCenter);
				mpImGui.DoImage(cImGuiGfx(), vLinePos, cVector2f(5.0f, fLineHeight)); //cVector2f(vLinePos.x, vLinePos.y+5.0f), cVector2f(vLinePos.x, vLinePos.y + fLineHeight), fZ, 5.0f, cColor(1, fAlpha));
				mpImGui.SetAlignment(eImGuiAlign_TopLeft);
								
				// Text frame
				mpImGui.DoTextFrame(msText, cVector2f(0), 0, 0, textFrameData, vTextFramePos, vTextFrameSize);
				
				// PATHOS logo
				cImGuiGfx gfxIcon("loading_pathos_logo.tga", eImGuiGfx_Texture);
				mpImGui.SetAlignment(eImGuiAlign_TopRight);
				mpImGui.DoImage(gfxIcon, vLinePos+cVector3f(-fSeparation,5.0f,0), GetRatioCorrectSizeByHeight(gfxIcon, fLineHeight-5.0f));
				
				if(mbLoading_LoadScreenHidden)
				{
					float fPromptAlpha = mpImGui.GetStateFloat("PromptAlpha");
					mpImGui.SetModColorMul(cColor(1,fAlpha*fPromptAlpha));
					
					cImGuiLabelData labelData;
					labelData.mFont.SetFile("sansation_medium.fnt");
					labelData.mFont.mvSize = cVector2f(28, 28);
					labelData.mFont.mColor = cColor(1,1);
					labelData.mFontAlign = eFontAlign_Center;
									
					gfxBlack.mColor.a = 0.75f;
					mpImGui.SetAlignment(eImGuiAlign_CenterCenter);
					mpImGui.DoImage(gfxBlack, NrmPos(0.5f, 0.5f, fZ+9.5f), NrmSize(1.0f, 0.0f) + cVector2f(0, labelData.mFont.mvSize.y*4.0f));
					
					mpImGui.DoLabel(cLux_Translate("LoadScreen", "PressToStart"), labelData, NrmPos(0.5f, 0.5f, fZ+10.0f));
				}
			}
			mpImGui.GroupEnd();
		}
		mpImGui.End();
	}
	
	cVector3f NrmPos(float afX, float afY, float afZ)
	{
		cVector2f vNrmSize = NrmSize(afX, afY);
		
		return cVector3f(vNrmSize.x, vNrmSize.y, afZ);
	}
	
	cVector2f NrmSize(float afX, float afY)
	{
		cVector2f vSize = mpScriptImGui.mpImGui.GetCurrentGroupSize();
		vSize.x *= afX;
		vSize.y *= afY;
		
		return vSize;
	}
	
	cVector2f GetRatioCorrectSizeByWidth(const cImGuiGfx &in aGfx, float afWidth)
{
	cVector2f vGfxSize = mpScriptImGui.mpImGui.GetGfxSize(aGfx);
	if (vGfxSize.x==0)
	{
		vGfxSize.x=1;
		vGfxSize.y=1;
	}
	
	float fRatio = vGfxSize.y/vGfxSize.x;
	
	return cVector2f(afWidth, afWidth*fRatio);
}

	cVector2f GetRatioCorrectSizeByNrmWidth(const cImGuiGfx &in aGfx, float afWidth)
	{
		return GetRatioCorrectSizeByWidth(aGfx, afWidth*mpScriptImGui.mpImGui.GetCurrentGroupSize().x);
	}

	cVector2f GetRatioCorrectSizeByHeight(const cImGuiGfx &in aGfx, float afHeight)
	{
		cVector2f vGfxSize = mpScriptImGui.mpImGui.GetGfxSize(aGfx);
		if (vGfxSize.x==0)
		{
			vGfxSize.x=1;
			vGfxSize.y=1;
		}
		
		float fRatio = vGfxSize.y/vGfxSize.x;
		
		return cVector2f(afHeight/fRatio, afHeight);
	}
	
	cLuxScriptImGui @mpScriptImGui;
	tString msEntry;
	tWString msText;
	
	bool mbFontSizeNeedsAdjust;
	float mfFontHeight;
	uint lNumMaxLines;
	uint lNumLinesInText;
		
	bool mbLoading_Started;
	bool mbLoading_LoadHeaderDone;
	bool mbLoading_LoadGameDone;
	bool mbLoading_LoadScreenHidden;
	bool mbDismiss;
};

cLastOnSomaScreen gLastOnSomaScreen;

//-----------------------------------------

bool gbFirstRun = true;
float mfMenuMusicVol = 0.35f;
float mfMenuCompMusicVol = 0.6f;

class cScrMenuHandler : iScrUserModule, iScrUserModule_Interface, iScrMenuHandler_Interface
{
	
	//------------------------------------------------------------
	
	/////////////////////////////////////////
	// INIT
	/////////////////////////////////////////
	
	//------------------------------------------------------------
	
	void Init()
	{
		mBaseObj.SetScriptableIsSaved(false);
		
		////////////////////////////////////
		// Options background
		cColor topCol(0.6f, 1.0f);
		mGfxFrame.mGfxCornerTopRight = cImGuiGfx("menu_corner_tr.tga");
		mGfxFrame.mGfxBorderTop = cImGuiGfx("menu_border_top.tga");
		mGfxFrame.mGfxCornerTopLeft = cImGuiGfx("menu_corner_tl.tga");
		mGfxFrame.mGfxBorderLeft = cImGuiGfx("menu_border_left.tga");
		mGfxFrame.mGfxBorderRight = cImGuiGfx("menu_border_right.tga");
		mGfxFrame.mGfxCornerBottomLeft = cImGuiGfx("menu_corner_bl.tga");
		mGfxFrame.mGfxCornerBottomRight = cImGuiGfx("menu_corner_br.tga");
		mGfxFrame.mGfxBorderBottom = cImGuiGfx("menu_border_bottom.tga");
		mGfxFrame.mGfxBackground.mColor = cColor(5.0f/255.0f, 60.0f/255.0f, 72.0f/255.0f, 0.25f);
		
		mGfxFrame.mColorCornerTopLeft = topCol;
		mGfxFrame.mColorCornerTopRight = topCol;
	}
	
	//------------------------------------------------------------
	
	void LoadUserConfig()
	{
	}
	
	//------------------------------------------------------------
	
	void SaveUserConfig()
	{
	}
	//------------------------------------------------------------
	
	/////////////////////////////////////////
	// INTERFACE
	/////////////////////////////////////////
	
	//------------------------------------------------------------
	
	void EnablePauseMenu(bool abX)
	{
		if(LoadScreen_IsVisible()) return;
	
		mbPauseMenuEnabled = abX;

		if(mbPauseMenuEnabled == false)
		{
			SetMenuActive(false);
		}
	}

	void ShowMainMenu(bool abX)
	{
		if(LoadScreen_IsVisible()) return;

		SetMenuActive(abX);
		mbMainMenuActive = abX;
		cLux_SetGamePaused(false);
		
		cLux_AddDebugMessage("Show menu: "+abX);

		if(abX)
		{
			////////////////////////////////
			// Variable setup
			mbPremenuActive = (mbShowPreMenu || Platform_IsPS4()) && gbFirstRun && !mbPauseMenuEnabled;
			
			if(mbPremenuActive)
			{
				mlPreMenuState =0;
				mbInitPreMenu=true;
				
				mbBackgroundShowTitle =false;
				mbBackgroundShowFace =false;
				mfBackgroundTitleAlpha=0;
				mfBackgroundFaceAlpha=0;
				
				mbMouseVisible = false;
				mbShowPressX = Platform_IsPS4();
				gbFirstRun = false;
				
				if(cLux_ScriptDebugOn())
				{
					//gbFirstRun = true;
				}
				
				mfMainAlpha =0;
			}
			else
			{
				mbBackgroundShowTitle =true;
				mbBackgroundShowFace =true;
				mfBackgroundTitleAlpha=0;
				mfBackgroundFaceAlpha=0;
				
				mbMouseVisible = true;
				mbShowPressX = false;

				mfMainAlpha = 1;
			}

			if(mbShowPreMenu)
			{
				tString sLang = mpConfig.GetString("Main", "StartLanguage", cLux_GetDefaultGameLanguage());
				if((sLang == "english" || sLang == "english.lang") == false)
				{
					mpConfig.SetBool("Sound", "ShowSubtitles", true);
				}
			}

			mbBackgroundTitleSounds = true;
			
			/////////////
			//Music
			if(mbPauseMenuEnabled==false && mbPremenuActive==false)
			{
                if(mCurrentBGPhase == eMainMenuPhase_AfterEnd)
                {
                    Music_PlayExt("Completion_MenuMusic", true, mfMenuCompMusicVol, 1.0f, 6.0f, 0.0f, eMusicPrio_OverrideAll, false);
                    //Sound_CreateAtEntity("MenuBGNoise", "special_fx/frontend/main_menu_bg", "Player", 6.0f, false, 0.75f);
                }
                else
                {
                    Music_PlayExt("Menu_Music", true, mfMenuMusicVol, 1.0f, 6.0f, 0.0f, eMusicPrio_OverrideAll, false);
                    //Sound_CreateAtEntity("MenuBGNoise", "special_fx/frontend/main_menu_bg", "Player", 6.0f, false, 1.0f);
                }
			}
				
						
			/////////////
			// If save files have not been checked, focus is set when that happens
			if(mbHasSaveFiles)
				msFocusNextFrame = mbCanContinue ? "Continue" : "NewGame";
		}
	}
	bool mbStartFocusNotSet = false;
	
	void SetMenuActive(bool abX)
	{
		cLux_SetGamePaused(abX);
		mbMenuActive = abX;

		if(mbMenuActive == false)
		{
			/////////////
			// Restore mouse input
			cLux_GetGuiHandler().SetGameHudInputFocus(false);
		}
		else
		{
			cLux_GetGuiHandler().SetGameHudInputFocus(true);
		}
		
		mbShowRestartWarning = false;
		mbShowApplyChanges = false;
		mbShowApplyKeyChanges = false;
		mbShowReset = false;
		mbShowExit = false;
		mbShowPlayGo = false;
		mbSaveAndExit = false;
		mbShowNewGame = false;
		mbShowLoadGame = false;
		mbShowDuplicateKeys = false;
		mbShowPressX = false;
		mbPremenuActive = false;
		mlActionToBind= 0;

		if(abX)
		{
			msFocusNextFrame = "ReturnToGame";
		
			mlClickedPauseMenuButton = -1;
			mlClickedMainMenuButton = -1;

			mCurrentGroup = eMainMenuGroup_Main;
		}
	}
	
	bool GetMenuActive()
	{
		return mbMenuActive;
	}
		
	void GameOver()
	{
		mbGameOver = true;
		EnablePauseMenu(false);
		ShowMainMenu(true);
	}
	
	void SetMainMenuPhase(eMainMenuPhase aPhase)
	{
		mCurrentBGPhase = aPhase;
		
		mpConfig.SetInt("Game", "MenuPhase", mCurrentBGPhase);
		mpConfig.Save();
	}
	
	void SetSaveLoadEnabled(bool abX)
	{
		cLux_AddDebugMessage("SetSaveLoadEnabled "+abX);
		mbSaveLoadEnabled = abX;
	}

	//------------------------------------------------------------
	
	/////////////////////////////////////////
	//MAP LOADING
	/////////////////////////////////////////
	
	//------------------------------------------------------------
	
	void Initiate(cLuxMap @apMap)
	{
		mbMainMenuActive = false;
		mbPauseMenuEnabled = true;
		msSelectedAudioButton = "Volume";
		msSelectedVideoButton = "AutoDetect";
		msSelectedInputButton = "Keybind";
		msSelectedInputMouseButton = "MouseSens";
		msSelectedInputGamepadButton = "GamepadMapping";
		msSelectedOptionsButton = "Gameplay";
		msSelectedPauseMenuButton = "ReturnToGame";
		msSelectedGammaButton = "Gamma";
		msSelectedVideoWorldButton ="TextureQuality"; 
		msSelectedVideoDisplayButton ="Resolution";
		msSelectedGameplayButton = "Language";
		msSelectedVideoGammaButton = "Gamma";
		msFocusNextFrame = "";
	
		mfFadeOut = 0.0f;

		if(apMap.GetName() == "main_menu")
		{
			mfFadeIn = 1.0;
		}

		mbMenuActive = false;

		////////////////
		// Setup multi select options
		@mpConfig = cLux_GetUserConfig();
		@mpKeyConfig = cLux_GetKeyConfig();

		//////////////
		// Load config
		mbFirstGameStart = mpConfig.GetBool("Main", "FirstGameStart", true);
		mbShowPreMenu = mpConfig.GetBool("Main", "ShowPreMenu", true);
		
		// If LargeFont has not been setup, make sure it's set to true for Russian.
		if (mpConfig.GetString("Sound", "UseLargeFont", "")=="")
		{
			tString sLang = mpConfig.GetString("Main", "StartLanguage", cLux_GetDefaultGameLanguage());
			if (sLang == "russian" || sLang == "russian.lang")
			{
				mpConfig.SetBool("Sound", "UseLargeFont", true);
				ApplySettings(true);
			}
		}
		
		/////////////
		// Setup resolutions
		mvResolutionValues.resize(0);
		mvResolutionSizes.resize(0);
		array<int> vBits;
		mvRefresh.resize(0);
		mvRefreshValues.resize(0);

		cSystem_GetAvailableVideoModes(mvResolutionSizes, vBits, mvRefresh, 32, 15, true);

		for(int i = 0; i < mvResolutionSizes.size(); ++i)
		{
			mvResolutionValues.push_back(""+mvResolutionSizes[i].x + "x"+mvResolutionSizes[i].y);
		}

		for(int i = 0; i < mvRefresh.size(); ++i)
		{
			mvRefreshValues.push_back(""+mvRefresh[i]);
		}

		if(mvLangFiles.size() == 0)
		{
			//////////////
			// Get lang files
			mvLangFiles.push_back("brazilian_portuguese");
			mvLangFiles.push_back("english");
			mvLangFiles.push_back("french");
			mvLangFiles.push_back("german");
			mvLangFiles.push_back("italian");
			mvLangFiles.push_back("russian");
			mvLangFiles.push_back("spanish");
		}

		/////////////////////
		// Actions
		array<cBindableAction> vActions = 
		{
			cBindableAction("Forward"),
			cBindableAction("Backward"),
			cBindableAction("Left"),
			cBindableAction("Right"),
			cBindableAction("Jump"),
			cBindableAction("Crouch"),
			cBindableAction("Run"),
			cBindableAction("LeanRight"),
			cBindableAction("LeanLeft"),
			cBindableAction("Interact"),
			cBindableAction("InteractCancel"),
			cBindableAction("InteractRotate"),
			cBindableAction("Flashlight"),
			cBindableAction("OpenInventory"),
			cBindableAction("Throw")
			// Removed to make binding simpler
			//cBindableAction("Examine")
		};

		mvActions = vActions;
		
		array<cBindableAction> vGamepadActions = 
		{
			cBindableAction("GamepadMove", true),
			cBindableAction("GamepadLook", true),
			cBindableAction("Jump"),
			cBindableAction("Crouch"),
			cBindableAction("Run"),
			cBindableAction("OpenInventory"),
			cBindableAction("Interact"),
			cBindableAction("Flashlight"),
			// Removed to make binding simpler
			//cBindableAction("Examine"),
			cBindableAction("InteractCancel"),
			cBindableAction("AnalogLean"),
			cBindableAction("Throw"),
			cBindableAction("GamepadRotateUp"),
			cBindableAction("GamepadRotateDown"),
			cBindableAction("GamepadRotateLeft"),
			cBindableAction("GamepadRotateRight"),
			cBindableAction("MenuConfirm"),
			cBindableAction("MenuCancel"),
			cBindableAction("MenuUp"),
			cBindableAction("MenuDown"),
			cBindableAction("MenuLeft"),
			cBindableAction("MenuRight"),
			cBindableAction("MenuScrollUp"),
			cBindableAction("MenuScrollDown"),
			cBindableAction("GamepadBack"),
			cBindableAction("OpenMenu")
		};
		mvGamepadActions = vGamepadActions;
		
		mCurrentBGPhase = eMainMenuPhase(mpConfig.GetInt("Game", "MenuPhase", eMainMenuPhase_Initial_To_1_3));

		mbInitiated = true;
	}

	void OnMapEnter(cLuxMap @apMap)
	{
		Initiate(apMap);
		
		
	}

	void OnMapLeave(cLuxMap @apMap)
	{
		mbPauseMenuEnabled = true;
		mbShowPressX = false;
		mbPremenuActive = false;
	}
	
	//------------------------------------------------------------
	
	void PreloadData(cLuxMap@ apMap)
	{
		//////////////////////////
		//Preload the pause menu
		ImGui_PreloadImage("menu_corner_tr.tga", eImGuiGfx_Image);
		ImGui_PreloadImage("menu_border_top.tga", eImGuiGfx_Image);
		ImGui_PreloadImage("menu_corner_tl.tga", eImGuiGfx_Image);
		ImGui_PreloadImage("menu_border_left.tga", eImGuiGfx_Image);
		ImGui_PreloadImage("menu_border_right.tga", eImGuiGfx_Image);
		ImGui_PreloadImage("menu_corner_bl.tga", eImGuiGfx_Image);
		ImGui_PreloadImage("menu_corner_br.tga", eImGuiGfx_Image);
		ImGui_PreloadImage("menu_border_bottom.tga", eImGuiGfx_Image);
		ImGui_PreloadImage("submenu_game.tga", eImGuiGfx_Image);
		ImGui_PreloadImage("submenu_options.tga", eImGuiGfx_Image);
		ImGui_PreloadImage("submenu_input.tga", eImGuiGfx_Image);
		ImGui_PreloadImage("submenu_video.tga", eImGuiGfx_Image);
		ImGui_PreloadImage("submenu_display.tga", eImGuiGfx_Image);
		ImGui_PreloadImage("submenu_rendering.tga", eImGuiGfx_Image);
		ImGui_PreloadImage("submenu_audio.tga", eImGuiGfx_Image);

		ImGui_PreloadImage("imgui_pointer_normal.tga", eImGuiGfx_Image);
		ImGui_PreloadImage("startmenu_button_long_jitter1", eImGuiGfx_Texture);
		ImGui_PreloadImage("startmenu_button_long_jitter2", eImGuiGfx_Texture);
		ImGui_PreloadImage("startmenu_button_long_jitter3", eImGuiGfx_Texture);
		ImGui_PreloadImage("startmenu_button_long_jitter4", eImGuiGfx_Texture);
		ImGui_PreloadImage("startmenu_button_long", eImGuiGfx_Texture);
		ImGui_PreloadImage("startmenu_options_button_long", eImGuiGfx_Texture);
		ImGui_PreloadImage("startmenu_options_button_meter", eImGuiGfx_Texture);
		ImGui_PreloadImage("startmenu_options_button_dropdown", eImGuiGfx_Texture);

		ImGui_PreloadImage("startmenu_options_msgbox_button_left.tga");
		ImGui_PreloadImage("startmenu_options_msgbox_button_right.tga");

		ImGui_PreloadImage("startmenu_options_button_on", eImGuiGfx_Image);
		ImGui_PreloadImage("startmenu_options_button_off", eImGuiGfx_Image);
		ImGui_PreloadImage("startmenu_options_arrow", eImGuiGfx_Image);
		
		ImGui_PreloadImage(Platform_IsPS4() ? "startmenu_button_x" : "startmenu_button_xbox_A", eImGuiGfx_Image); 
		ImGui_PreloadImage(Platform_IsPS4() ? "startmenu_button_circle" : "startmenu_button_xbox_B", eImGuiGfx_Image);
		ImGui_PreloadImage("startmenu_button_direction2", eImGuiGfx_Image);
		
		Sound_PreloadGroup("special_fx/frontend", true);
	}
	
	void CreateWorldEntities(cLuxMap @apMap)
	{
	
	}
	void DestroyWorldEntities(cLuxMap @apMap)
	{
	
	}
	
	//------------------------------------------------------------
	
	/////////////////////////////////////////
	// GENERAL
	/////////////////////////////////////////
	
	//------------------------------------------------------------
	
	void OnEnterContainer(const tString&in asOldContainer)
	{
	
	}
	void OnLeaveContainer(const tString&in asNewContainer)
	{
	
	}
	
	//------------------------------------------------------------
	
	void Update(float afTimeStep)
	{
	}
	
	void PostUpdate(float afTimeStep)
	{
	}
	
	void Reset()
	{
	}
	void VariableUpdate(float afDeltaTime)
	{
		
	}

	//------------------------------------------------------------
	
	/////////////////////////////////////////
	// ACTIONS
	/////////////////////////////////////////
	
	//------------------------------------------------------------
	
	void OnGui(float afTimeStep)
	{
		if(mbInitiated == false && cLux_GetCurrentMap() !is null)
		{
			Initiate(cLux_GetCurrentMap());
		}

		///////////////////////////////////
		// Display ScriptDebug ON message, to ease confusion
		if(cLux_ScriptDebugOn())
		{
			ImGui_SetTransCategory("");
			
			ImGui_GroupBegin(cLux_GetHudVirtualCenterScreenStartPos(), cLux_GetHudVirtualCenterScreenSize());
				
			cImGuiLabelData labelData;
			labelData.mColorBase = cColor(1.0f,0.3f,1.0f);
			ImGui_DoLabelExt("ScriptDebug ON", labelData, cVector3f(5.0f,ImGui_GetCurrentGroupSize().y-20.0f,100.0f), -1,1.0f);
			ImGui_GroupEnd();
		}

		//////////////////////////////////
		// Check for load save error
		tString sError;
		if(cLux_GetSaveHandler().HasLoadError(sError))
		{
			msLoadSaveError = sError;
			mbProfileError = false;
			
			if(mbMenuActive == false) 
			{
				if(mbMainMenuActive)	ShowMainMenu(true);
				else					SetMenuActive(true);
			}

			if(msLoadSaveError == "NoSpace") msLoadSaveError = ""; //solved on a OS level
			if(msLoadSaveError == "PlayGo")
			{
				mbShowPlayGo = true;
				msLoadSaveError = "";
			}
		}

		if(cLux_HasConfigLoadError(sError))
		{
			msLoadSaveError = sError;
			mbProfileError = true;
			
			if(mbMenuActive == false) 
			{
				if(mbMainMenuActive)	ShowMainMenu(true);
				else					SetMenuActive(true);
			}
		}
		
		//////////////////////////////////////
		// LAST ON SOMA screen handling
		gLastOnSomaScreen.Update(afTimeStep);
		
		if(gLastOnSomaScreen.IsActive() || mbMenuActive == false) 
			return;
			
		
		if(mbMainMenuActive && mbHasSaveFiles == false)
		{
			/////////////
			// Save files
			if(cLux_GetSaveHandler().GetSaveFiles(mvSaveNames, mvSaveDates, mvSaveFiles))
			{
				mbHasSaveFiles = true;
				mbCanContinue = mvSaveFiles.size() > 0;
				
				// Set focus here
				msFocusNextFrame = mbCanContinue ? "Continue" : "NewGame";
				
				if(mbCanContinue)
				{
					msContinueFile = mvSaveFiles[0]; 

					///////////
					// Remove "CheckPoint" from save file list
					for(int i = 0; i < mvSaveFiles.size(); ++i)
					{
						if(mvSaveNames[i] == tWString("CheckPoint"))
						{
							for(int j = i + 1; j < mvSaveFiles.size(); ++j)
							{
								mvSaveFiles[j-1] = mvSaveFiles[j];
								mvSaveDates[j-1] = mvSaveDates[j];
								mvSaveNames[j-1] = mvSaveNames[j];	
							}
						
							mvSaveFiles.resize(mvSaveFiles.size()-1);
							mvSaveDates.resize(mvSaveDates.size()-1);
							mvSaveNames.resize(mvSaveNames.size()-1);

							break;
						}
					}
				}
			}
			else
			{
				// Don't let menu continue until saves have been checked
				//cLux_AddDebugMessage("Saves not retrieved yet...");
				return;
			}
		}
		
		
		//////////////////////////////////
		// Main alpha
		if(mbPremenuActive)
			mfMainAlpha = cMath_IncreaseTo(mfMainAlpha, afTimeStep*0.5f, 0.0f);
		else
			mfMainAlpha = cMath_IncreaseTo(mfMainAlpha, afTimeStep*0.5f, 1.0f);

		/////////////////////////////////////
		//Renders a in game mouse pointer.
		cImGuiGfx mouseGfx("imgui_pointer_normal.tga");
		mouseGfx.mColor = cColor_White;
		if(ImGui_GetMouseVisible() && mbMouseVisible)
			ImGui_DoMouse(mouseGfx, cVector3f_Zero);
		
		/////////////////////////////////////
		//Setup Properties
		cGuiSet@ pSet = cLux_GetCurrentImGui().GetSet();
		mvSize = pSet.GetVirtualSize();
		mvOffset = pSet.GetVirtualSizeOffset();
		mvAspectRatio = cGraphics_GetLowLevel().GetScreenSizeFloat();
		mvAspectRatio /= mvAspectRatio.y;
		mlActionHorizontal = 0;
		
		ImGui_SetTransCategory("Menu");

		@mpConfig = cLux_GetUserConfig();
		@mpKeyConfig = cLux_GetKeyConfig();
		
		/////////////////////////////////////
		//Set frame focus
		if(msFocusNextFrame != "")
		{
			//////////
			// Setup focus when changing groups
			ImGui_SetFocus(msFocusNextFrame);
			msFocusNextFrame = "";
		}
		
		/////////////////////////////////////
		// MainMenu-Button Press Check
		if(mbMenuButtonPressed && mbPremenuActive == false && mbShowPressX == false)
		{
			mbMenuButtonPressed = false;
			if(mCurrentGroup == eMainMenuGroup_Main && ((mbShowApplyChanges || mbShowApplyKeyChanges || mbShowDuplicateKeys || mbShowReset ||  mbShowRestartWarning || mbShowExit || mbShowPlayGo || mbShowNewGame || mbShowLoadGame || mfKeepDisplaySetting > 0 || mlActionToBind > 0) == false))
			{
				if(mbMainMenuActive == false)
				{
					/////////////
					// Disable menu
					SetMenuActive(false);
					return;
				}
				else
				{
					////////////
					// Show exit menu
					//mlClickedMainMenuButton = 4;
					//ImGui_AddTimer("ButtonClicked", 0.15);
					//cLux_AddTodoMessage("Sound: Menu main button pressed");
				}
			}
			else
			{
				//////////////
				// Map menu button to back button
				cLux_GetCurrentImGui().SendAction(eImGuiAction_Cancel, true, true);
			}
		}
		mbMenuButtonPressed = false;
		
		
		//////////////////////////////////////////////
		// Message box
		if(	mbShowApplyChanges || mbShowDuplicateKeys || 
			mbShowApplyKeyChanges || mbShowReset || 
			mbShowRestartWarning || mbShowExit || mbShowPlayGo ||
			mbShowNewGame || mbShowLoadGame || 
			mbShowDetectSettings ||
			mfKeepDisplaySetting > 0 || mlActionToBind > 0 || 
			(msLoadSaveError.length() > 0 && mbPremenuActive == false))
		{
			////////////////
			// Display message box and disable input for any other widgets
			ShowMessageBoxes();
			ImGui_SetModUseInput(false); 
		}
		///////////////
		// Catch left and right input
		else
		{
			float fStartingTimer = 0.35f;
			float fFinalTimer = 0.25;
			float fTimerReductionFactor = 0.8f;
			
			{
				if(ImGui_ActionTriggered(eImGuiAction_Right, true))
				{
					mlActionHorizontal++;
					
					ImGui_SetStateFloat("HoriPressTimer", fStartingTimer);
					ImGui_AddTimer("RightPressed", fStartingTimer);
				}
							
				if(ImGui_ActionTriggered(eImGuiAction_Left, true))
				{
					mlActionHorizontal--;
					
					ImGui_SetStateFloat("HoriPressTimer", fStartingTimer);
					ImGui_AddTimer("LeftPressed", fStartingTimer);
				}
			}
			
			if(ImGui_TimerExists("RightPressed"))
			{
				if(ImGui_ActionIsDown(eImGuiAction_Right)==false)
				{
					ImGui_StopTimer("RightPressed");
				}
				else
				{
					if(ImGui_TimerOver("RightPressed"))
					{
						mlActionHorizontal++;
						
						float fTimer = ImGui_GetStateFloat("HoriPressTimer");
						fTimer *= fTimerReductionFactor;
						if(fTimer<fFinalTimer)
							fTimer = fFinalTimer;

						ImGui_SetStateFloat("HoriPressTimer", fTimer);
						ImGui_AddTimer("RightPressed", fTimer);
					}
				}
			}
			
			if(ImGui_TimerExists("LeftPressed"))
			{
				if(ImGui_ActionIsDown(eImGuiAction_Left)==false)
					ImGui_StopTimer("LeftPressed");
				else
				{
					if(ImGui_TimerOver("LeftPressed"))
					{
						mlActionHorizontal--;
						
						float fTimer = ImGui_GetStateFloat("HoriPressTimer");
						fTimer *= fTimerReductionFactor;
						if(fTimer<fFinalTimer)
							fTimer = fFinalTimer;

						ImGui_SetStateFloat("HoriPressTimer", fTimer);
						
						ImGui_AddTimer("LeftPressed", fTimer);
					}
				}
			}
			
			ImGui_SetModUseInput(true); 
		}

		///////////////
		// Applying key config might cause actions to fire again, so ignore them
		if(mlIgnoreInput > 0)
		{
			mlIgnoreInput--;
			ImGui_SetModUseInput(false);
			ImGui_ActionTriggered(eImGuiAction_Cancel, true);
		}

		/////////////
		// Draw & Update Background
		GuiBackground(afTimeStep);
		
		/////////////
		// Fade screen and execute action
		if(	ImGui_TimerExists("NewGame") || 
			ImGui_TimerExists("Continue") ||
			ImGui_TimerExists("LoadGame") ||
			ImGui_TimerExists("ExitToMainMenu") ||
			ImGui_TimerExists("ExitGame"))
		{
			/////////////
			// Fade to black
			if(ImGui_TimerExists("ExitGame"))
				mfFadeOut += afTimeStep / mfExitGameFadeLength;
			else if(ImGui_TimerExists("NewGame"))
				mfFadeOut += afTimeStep / gfNewGameFadeOutTime;
			else
				mfFadeOut += afTimeStep / mfFadeLength;
				
			if(mfFadeOut>1) mfFadeOut=1;
				
			cImGuiGfx gfx;
			ImGui_DrawGfx(gfx, ImGui_NrmPos(0,0, 60.0f), ImGui_NrmSize(1.0), cColor(0, mfFadeOut));
			ImGui_SetModUseInput(false); 

			///////////////////////////
			// Action: New Game
			if(ImGui_TimerOver("NewGame"))
			{
				ImGui_StopTimer("NewGame");
				SetMenuActive(false);
				mbGameOver = false;
				msPreviousSaveLoaded = "";
				
				cLux_StartNewGame();

				
				return;
			}
			
			///////////////////////////
			// Action: Continue
			if(ImGui_TimerOver("Continue"))
			{
				ImGui_StopTimer("Continue");
				StartSavedGameLoad(msContinueFile);
				
				return;
			}

			///////////////////////////
			// Action: Load Game
			if(ImGui_TimerOver("LoadGame"))
			{
				ImGui_StopTimer("LoadGame");
				StartSavedGameLoad(mvSaveFiles[mlSaveFileToLoad]);
								
				return;
			}
			
			///////////////////////////
			// Action: Exit To Main menu
			if(ImGui_TimerOver("ExitToMainMenu"))
			{
				ImGui_StopTimer("ExitToMainMenu");
				mbGameOver = false;
				cLux_GetEffectHandler().FadeOut(0.0);
				
				cLux_StartMap(cLux_GetMainMenuFile());
				msPreviousSaveLoaded = "";

				LoadScreen_SetUseSmallIcon(false); 
				SetMenuActive(false);
								
				return;
			}
			
			if(ImGui_TimerOver("ExitGame"))
			{
				ImGui_StopTimer("ExitGame");
				mbGameOver = false;
				cLux_GetEffectHandler().FadeOut(0.0);
				SetMenuActive(false);
				cLux_Exit();
				
				return;
			}
		}
		/////////////
		// Set focus back to this set!
		else
		{
			if(cLux_GetGuiHandler().GetGameHudInputFocus() == false)
			{
				cLux_GetGuiHandler().SetGameHudInputFocus(true);
			}
		}
		
		/////////////
		// Fade to black
		if(mfFadeIn > 0.0f)
		{
			mfFadeIn -= afTimeStep / mfFadeLength;
			cImGuiGfx gfx;
			ImGui_DrawGfx(gfx, ImGui_NrmPos(0,0,60), ImGui_NrmSize(1.0), cColor(0, mfFadeIn));
		}
		
		if(mbPremenuActive==false)
			OptionMenu_SetModColor(cColor(1, mfMainAlpha));
			
		
		/////////////
		// Draw current state
		switch(mCurrentGroup)
		{
			////////////////
			// Main menu
			case eMainMenuGroup_Main:
			{
				if(mbMainMenuActive)
				{
					////////////
					// Gamma correction pre menu
					if(mbPremenuActive) 
					{
						GuiPreMenu(afTimeStep);
					}
					/////////////
					// Main menu
					else {
						GuiMainMenuSelection();
					}
				}
				////////////////
				// Pause menu
				else
				{
					GuiPauseMenuSelection();
				}
				break;
			}
			//////////////
			// StartGame
			case eMainMenuGroup_StartGame:
			{
				GuiStartGame();break;
			}
			//////////////
			// LoadGame
			case eMainMenuGroup_LoadGame:
			{
				GuiLoadGame();break;
			}
			//////////////
			// Options
			case eMainMenuGroup_Options:
			{
				GuiOptions();break;
			}
			//////////////
			// Input Options
			case eMainMenuGroup_Options_Input:
			{
				GuiOptionsInput();break;
			}
			//////////////
			// Keybind
			case eMainMenuGroup_Options_Input_Keybind:
			{
				GuiOptionsInputKeybind();break;
			}
			//////////////
			// Mouse input Options
			case eMainMenuGroup_Options_Input_Mouse:
			{
				GuiOptionsInputMouse(); break;
			}			
			//////////////
			// Gamepad input options
			case eMainMenuGroup_Options_Input_Gamepad:
			{
				GuiOptionsInputGamepad(); break;
			}
			//////////////
			// Gamepad mapping
			case eMainMenuGroup_Options_Input_GamepadMapping:
			{
				GuiOptionsInputMapping();break;
			}
			//////////////
			// Gameplay Options
			case eMainMenuGroup_Options_Gameplay:
			{
				GuiOptionsGameplay();break;
			}
			//////////////
			// Video Options
			case eMainMenuGroup_Options_Video:
			{
				GuiOptionsVideo();break;
			}
			//////////////
			// Display Video Options
			case eMainMenuGroup_Options_Video_Display:
			{
				GuiOptionsVideoDisplay();break;
			}
			//////////////
			// PostEffect Video Options
			case eMainMenuGroup_Options_Video_PostEffect:
			{
				GuiOptionsVideoPostEffect();break;
			}
			//////////////
			// World Video Options
			case eMainMenuGroup_Options_Video_World:
			{
				GuiOptionsVideoWorld();break;
			}
			//////////////
			// Gamma Video Options
			case eMainMenuGroup_Options_Video_Gamma:
			{
				if(mbPauseMenuEnabled)
				{
					GuiOptionsVideoGamma();break;
				}
				else
				{
					GuiGammaCorrection();break;
				}
			}
			//////////////
			// Audio Options
			case eMainMenuGroup_Options_Audio:
			{
				GuiOptionsAudio();break;
			}
		}
		
		OptionMenu_SetModColor(cColor(1, 1));
		OptionMenu_ResetExtraWidth();
		
		ImGui_SetTransCategory("");
		
		if(mbMainMenuActive)
		{
			cLux_GetCurrentImGui().ClipAreaBegin(cLux_GetHudVirtualCenterScreenStartPos(), cLux_GetHudVirtualCenterScreenSize());
				//DrawParticles(afTimeStep);
			cLux_GetCurrentImGui().ClipAreaEnd();
		}
	}
	
	//-------------------------------------------------------
	
	void StartSavedGameLoad(const tWString &in asFile)
	{
		mbGameOver = false;
		cLux_GetSaveHandler().DelayedLoadGameFromFile(asFile, "", "", true, true);
		msPreviousSaveLoaded = asFile;
		LoadScreen_SetUseSmallIcon(true); 
		LoadScreen_SetForceBackground(false);
		SetMenuActive(false);
		
		gLastOnSomaScreen.LoadingStarted();
		
		//gbMainMenuLoadingSavedGameStarted = true;
		//gbMainMenuLoadingSavedGame_LoadHeaderDone = false;
		//gbMainMenuLoadingSavedGameDone = false;
	}
	
	//-------------------------------------------------------
	
	cImGuiParticleEmitter mEmitterLowerHalf;
	cImGuiParticleEmitter mEmitterUpperHalf;
	cImGuiParticleEmitter mEmitterLarge;
	cImGuiParticleEmitter mEmitterSmoke;
	bool mbEmitterSet = false;
	eMainMenuPhase mCurrentBGPhase = eMainMenuPhase_Initial_To_1_3;
	float mfBGAnimationTime = 0.0f;
	float mfMinRedLightFlickerTime = 0.5f;
	float mfMaxRedLightFlickerTime = 1.0f;
	
	float mfFrontFaceScale = 0.7f;
	float mfBackFaceScale = 0.3f;
	
	bool mbShowingGammaMenu = false;
	
	void DrawParticles(float afTimeStep)
	{
		if(mbEmitterSet==false)
		{
			mbEmitterSet = true;
			
			mEmitterLowerHalf.mvGfx.insertLast(cImGuiGfx("dust_light_tiny.dds", eImGuiGfx_Texture));
			
			mEmitterLowerHalf.mvMin = OptionMenu_GetBotRightOffset(cVector2f(0,0), 1.0f);
			mEmitterLowerHalf.mvMax = OptionMenu_GetBotRightOffset(cVector2f(0,0), 2.0f);
			mEmitterLowerHalf.mvMin.y = ImGui_NrmSize(0, 0.5f).y;
			mEmitterLowerHalf.mvMax.y = ImGui_NrmSize(0, 1.0f).y;
			
			mEmitterLowerHalf.mvVelocityMin = cVector3f(-10.0f, 0, 0);
			mEmitterLowerHalf.mvVelocityMax = cVector3f(-30.0f, 10, 0);
			
			mEmitterLowerHalf.mfSizeMin = 0.1f;
			mEmitterLowerHalf.mfSizeMax = 0.25f;
			mEmitterLowerHalf.mlMaxParticles = 100;
			mEmitterLowerHalf.mfParticlesPerSec = 10.0f;
			
			mEmitterLowerHalf.mfMinLife = 15.0f;
			mEmitterLowerHalf.mfMaxLife = 35.0f;
			
			mEmitterLowerHalf.mColorStartMin = cColor(0.7f,0.25f);
			mEmitterLowerHalf.mColorStartMax = cColor(0.7f,0.75f);
			mEmitterLowerHalf.mColorMulStart = cColor(1,1);
			mEmitterLowerHalf.mColorMulMiddle = cColor(1,1);
			mEmitterLowerHalf.mColorMulEnd = cColor(1,0);
			
			mEmitterLowerHalf.mfColorMulEndStartTime = 0.8f;
			
			
			mEmitterUpperHalf.mvGfx.insertLast(cImGuiGfx("dust_light_tiny.dds", eImGuiGfx_Texture));
			
			mEmitterUpperHalf.mvMin = OptionMenu_GetBotRightOffset(cVector2f(0,0), 1.0f);
			mEmitterUpperHalf.mvMax = OptionMenu_GetBotRightOffset(cVector2f(0,0), 2.0f);
			mEmitterUpperHalf.mvMin.y = ImGui_NrmSize(0, 0.0f).y;
			mEmitterUpperHalf.mvMax.y = ImGui_NrmSize(0, 0.5f).y;
			
			mEmitterUpperHalf.mvVelocityMin = cVector3f(-10.0f, 0, 0);
			mEmitterUpperHalf.mvVelocityMax = cVector3f(-30.0f, 10, 0);
					
			mEmitterUpperHalf.mfSizeMin = 0.1f;
			mEmitterUpperHalf.mfSizeMax = 0.25f;
			mEmitterUpperHalf.mlMaxParticles = 100;
			mEmitterUpperHalf.mfParticlesPerSec = 5.0f;
					
			mEmitterUpperHalf.mfMinLife = 5.0f;
			mEmitterUpperHalf.mfMaxLife = 20.0f;
					
			mEmitterUpperHalf.mColorStartMin = cColor(0.7f, 0.25f);
			mEmitterUpperHalf.mColorStartMax = cColor(0.7f, 0.75f);
			mEmitterUpperHalf.mColorMulStart = cColor(1,1);
			mEmitterUpperHalf.mColorMulMiddle = cColor(1,1);
			mEmitterUpperHalf.mColorMulEnd = cColor(1,0);
					
			mEmitterUpperHalf.mfColorMulEndStartTime = 0.8f;
			
			mEmitterLarge.mvGfx.insertLast(cImGuiGfx("dust_light_tiny.dds", eImGuiGfx_Texture));
			
			mEmitterLarge.mvMin = OptionMenu_GetBotRightOffset(cVector2f(0,0), 1.0f);
			mEmitterLarge.mvMax = OptionMenu_GetBotRightOffset(cVector2f(0,0), 2.0f);
			mEmitterLarge.mvMin.y = ImGui_NrmSize(0, 0.0f).y;
			mEmitterLarge.mvMax.y = ImGui_NrmSize(0, 1.0f).y;
			
			mEmitterLarge.mvVelocityMin = cVector3f(-10.0f, 0, 0);
			mEmitterLarge.mvVelocityMax = cVector3f(-30.0f, 10, 0);
			
			mEmitterLarge.mfSizeMin = 0.3f;
			mEmitterLarge.mfSizeMax = 0.5f;
			mEmitterLarge.mlMaxParticles = 100;
			mEmitterLarge.mfParticlesPerSec = 2.0f;
			
			mEmitterLarge.mfMinLife = 5.0f;
			mEmitterLarge.mfMaxLife = 20.0f;
			
			mEmitterLarge.mColorStartMin = cColor(0.5f,0.25f);
			mEmitterLarge.mColorStartMax = cColor(0.5f,0.75f);
			mEmitterLarge.mColorMulStart = cColor(1,1);
			mEmitterLarge.mColorMulMiddle = cColor(1,1);
			mEmitterLarge.mColorMulEnd = cColor(1,0);
			
			mEmitterLarge.mfColorMulEndStartTime = 0.8f;
			
			
			cImGuiGfx gfxCloudParticle("dust_cloud.dds", eImGuiGfx_Texture);
			gfxCloudParticle.mMaterial = eGuiMaterial_Additive;
			gfxCloudParticle.mvUVMin = cVector2f(0.0f, 0.0f);
			gfxCloudParticle.mvUVMax = cVector2f(0.5f, 0.5f);
			mEmitterSmoke.mvGfx.insertLast(gfxCloudParticle);
			gfxCloudParticle.mvUVMin = cVector2f(0.0f, 0.5f);
			gfxCloudParticle.mvUVMax = cVector2f(0.5f, 1.0f);
			mEmitterSmoke.mvGfx.insertLast(gfxCloudParticle);
			gfxCloudParticle.mvUVMin = cVector2f(0.5f, 0.0f);
			gfxCloudParticle.mvUVMax = cVector2f(1.0f, 0.5f);
			mEmitterSmoke.mvGfx.insertLast(gfxCloudParticle);
			gfxCloudParticle.mvUVMin = cVector2f(0.5f, 0.5f);
			gfxCloudParticle.mvUVMax = cVector2f(1.0f, 1.0f);
			mEmitterSmoke.mvGfx.insertLast(gfxCloudParticle);
			
			mEmitterSmoke.mvMin = OptionMenu_GetBotRightOffset(cVector2f(0,0), 1.0f);
			mEmitterSmoke.mvMax = OptionMenu_GetBotRightOffset(cVector2f(0,0), 2.0f);
			mEmitterSmoke.mvMin.y = ImGui_NrmSize(0, 0.0f).y;
			mEmitterSmoke.mvMax.y = ImGui_NrmSize(0, 1.0f).y;
			
			mEmitterSmoke.mvVelocityMin = cVector3f(-20.0f, 0, 0);
			mEmitterSmoke.mvVelocityMax = cVector3f(-20.0f, 10, 0);

			mEmitterSmoke.mfSizeMin = 1.0f;
			mEmitterSmoke.mfSizeMax = 3.0f;
			mEmitterSmoke.mlMaxParticles = 50;
			mEmitterSmoke.mfParticlesPerSec = 0.5f;

			mEmitterSmoke.mfMinLife = 30.0f;
			mEmitterSmoke.mfMaxLife = 100.0f;

			mEmitterSmoke.mColorStartMin = cColor(0.25f,1.0f);
			mEmitterSmoke.mColorStartMax = cColor(0.5f,1.0f);
			mEmitterSmoke.mColorMulMiddle = cColor(0.5f,0.5f);
			mEmitterSmoke.mColorMulEnd = cColor(0,0);

			mEmitterSmoke.mfColorMulEndStartTime = 0.8f;
			
			for(int i=0; i<1200; ++i)
			{
				mEmitterUpperHalf.Update(afTimeStep);
				mEmitterLowerHalf.Update(afTimeStep);
				mEmitterLarge.Update(afTimeStep);
				mEmitterSmoke.Update(afTimeStep);
			}
		}
		
		mEmitterUpperHalf.Draw(afTimeStep);
		mEmitterLowerHalf.Draw(afTimeStep);
		mEmitterLarge.Draw(afTimeStep);
		mEmitterSmoke.Draw(afTimeStep);
	}
	
	void GuiBackground(float afTimeStep)
	{
/*		if(mbMainMenuActive)
		{
			/////////////////////////////////////
			// Background
			cImGuiGfx gfx("menu_background.tga", eImGuiGfx_Texture);
			ImGui_DrawGfx(gfx, OptionMenu_GetTopLeftOffset(cVector2f(0,0), -1.0f), OptionMenu_GetScaledSize(cVector2f(1280,720)));
			
			
			
			//////////////////////////////////////
			// Title alpha
			if(	mbBackgroundShowTitle)
			{
				mfBackgroundTitleAlpha = cMath_IncreaseTo(mfBackgroundTitleAlpha, afTimeStep*0.5, 1.0f);
			}
			else
			{
				mfBackgroundTitleAlpha = cMath_IncreaseTo(mfBackgroundTitleAlpha, afTimeStep*0.5, 0.0f);
			}
			
			/////////////////////////////////////
			//Title
			if(mfBackgroundTitleAlpha>0)
			{
				cImGuiGfx gfxTitle("startmenu_title.tga", eImGuiGfx_Texture);
				if(ImGui_TimerExists("TitleGlitchWait")==false)
				{
					ImGui_AddTimer("TitleGlitchWait", cMath_RandRectf(4.0f, 7.0f));
				}
				if(ImGui_TimerOver("TitleGlitchWait"))
				{
					ImGui_SetStateInt("TitleGlitchTimes", cMath_RandRectl(3, 5));
					
					//ImGui_FadeStateColor("LightColor", cColor(0.8f, 0.5f), cMath_RandRectf(0.05f, 0.25f), eEasing(cMath_RandRectl(int(eEasing_Linear), int(eEasing_LastEnum))));
				}
				
				int lTitleDistortTimes = ImGui_GetStateInt("TitleGlitchTimes",0);
				
				if(lTitleDistortTimes>0 && ImGui_TimerExists("TitleGlitch")==false)
				{
					ImGui_AddTimer("TitleGlitch", 0);
					if(mbBackgroundTitleSounds)
						Sound_PlayGui("special_fx/frontend/menu_glitch", 1.0f, eSoundEntryType_Gui);
				}
				
				if(ImGui_TimerOver("TitleGlitch"))
				{
					if(lTitleDistortTimes>0)
					{
						ImGui_SetStateInt("TitleGlitchPic", cMath_RandRectl(1,4));
						ImGui_IncStateInt("TitleGlitchTimes", -1);
						
						ImGui_AddTimer("TitleGlitch", cMath_RandRectf(0.01f, 0.1f));
					}
					else
					{
						ImGui_SetStateInt("TitleGlitchPic", 0);
					}
				}
			
			
				cColor colorMul(1, mfBackgroundTitleAlpha);
				
				bool bTitleGlitching = false;
				int lTitlePic = ImGui_GetStateInt("TitleGlitchPic", 0);
				if(lTitlePic>0)
				{
					gfxTitle.SetFile("startmenu_title_flicker" + lTitlePic + ".tga");
				
					bTitleGlitching = true;
				}
				
				if(ImGui_TimerExists("TitlePulse")==false)
				{
					ImGui_AddTimer("TitlePulse", cMath_RandRectf(1, 4));
				}
				
				if(ImGui_TimerOver("TitlePulse"))
				{
					float fComponent = cMath_RandRectf(0.5f, 3.0f);
					cColor goalColor(fComponent, cMath_Clamp(fComponent, 0, 1.0f));
					ImGui_FadeStateColor("TitleColor", goalColor, cMath_RandRectf(0.05f, 0.25f), eEasing(cMath_RandRectl(int(eEasing_Linear), int(eEasing_LastEnum))));
				}
				
				if(ImGui_FadeOver("TitleColor"))
				{
					ImGui_SetStateColor("TitleColor", cColor_White);
					ImGui_AddTimer("TitlePulseWait", cMath_RandRectf(1.0f, 4.0f));
				}
				
				cColor titleCol = ImGui_GetStateColor("TitleColor", cColor(1.0, 1.0));
				ImGui_DrawGfx(gfxTitle, OptionMenu_GetTopLeftOffset(kTitlePos, 0.0), OptionMenu_GetScaledSize(kTitleSize), titleCol*colorMul);
				
				if(bTitleGlitching)
					ImGui_DrawGfx(cImGuiGfx("startmenu_title.tga", eImGuiGfx_Texture), OptionMenu_GetTopLeftOffset(kTitlePos+cVector2f(20.0f), 1.0), OptionMenu_GetScaledSize(kTitleSize), cColor(1.0, 0.5f)*colorMul);
			}
		
		}*/
		if(mCurrentGroup!=eMainMenuGroup_Options_Video_Gamma && !mbMainMenuActive)
		{
			/////////////////////////////////////
			// Background
			cImGuiGfx gfx;
			ImGui_DrawGfx(gfx, ImGui_NrmPos(0, 0, 19.0), ImGui_NrmSize(1.0), cColor(0, 0.75));
		}
	}

	
	
	void GuiBackground_DrawCathFacePart(const cImGuiGfx &in aGfx, 
										const cVector3f &in avFrontCenterPos, const cVector3f &in avBackCenterPos, 
										float afFrontScale, float afBackScale,
										const cColor &in aFrontCol, const cColor &in aBackCol,
										uint alLayers)
	{
		if(alLayers==0)	alLayers = 1;
		
		cVector2f vOriginalSize = OptionMenu_GetScaledSize(GetUsedGfxSize(aGfx, -1));
		cVector2f vSize = vOriginalSize*afFrontScale;
		
		ImGui_DrawAlignedGfx(aGfx, avFrontCenterPos, eImGuiAlign_CenterCenter, vSize, aFrontCol);
		
		if(alLayers==1) return;
		
		alLayers--;
		
		cVector3f vDir = avBackCenterPos-avFrontCenterPos; 
		float fDistance = vDir.Normalize();
		cVector3f vStep = vDir*fDistance/alLayers;
		
		float fScale = afFrontScale;
		float fScaleDiff = afBackScale-afFrontScale;
		float fScaleStep = fScaleDiff/alLayers;
		
		cColor colStep(aBackCol.r-aFrontCol.r, aBackCol.g-aFrontCol.g, aBackCol.b-aFrontCol.b, aBackCol.a-aFrontCol.a);
		colStep.r /= alLayers;
		colStep.g /= alLayers;
		colStep.b /= alLayers;
		colStep.a /= alLayers;
		
		cVector3f vPos = avFrontCenterPos;
		cColor col = aFrontCol;
		
		for(uint i=0; i<alLayers; ++i)
		{
			vPos += vStep;
			fScale += fScaleStep;
			vSize = vOriginalSize*fScale;
			
			col.r += colStep.r;
			col.g += colStep.g;
			col.b += colStep.b;
			col.a += colStep.a;
			
			ImGui_DrawAlignedGfx(aGfx, vPos, eImGuiAlign_CenterCenter, vSize, col);
		}
	}
	
	//-------------------------------------------------------
	
	void ClickNewGame()
	{
		//New game sting
		Sound_PlayGui("special_fx/frontend/new_game_sting", 1.0f, eSoundEntryType_Gui);
        Sound_Stop("MenuBGNoise", mfFadeLength);
		
		// No continue or load button, no need to confirm
		ImGui_AddTimer("NewGame", gfNewGameFadeOutTime+0.6f);
		cSound_FadeOutAll(eSoundEntryType_WorldAll, 1.0f / gfNewGameFadeOutTime, false);
		
		//Fade out music quickly to stop the new game stinger from being out of key with the music
		Music_StopAll(1.0f);
		
		
		cLux_GetGuiHandler().SetGameHudInputFocus(false);
		mbShowNewGame = false;
		mbBackgroundTitleSounds = false;
	}
	
	//-------------------------------------------------------

	void GuiMainMenuSelection()
	{		
		/////////////////
		// Continue
		if (mbSaveLoadEnabled == false)
		{
		}
		else if(mbCanContinue && !mbGameOver)
		{
			if(OptionMenu_ButtonMainMenu("Continue", kMainMenuButtonPos,0, msSelectedMainMenuButton, mlClickedMainMenuButton))
			{
				mlClickedMainMenuButton = 0;
				Sound_Stop("MenuBGNoise", 2.0f);
				Music_StopAll(2.0f);
			}
            
			msSelectedMainMenuButton = OptionMenu_UpdateFocus("Continue", msSelectedMainMenuButton);
		}
		else
		{
			//////////////
			// Not possible to continue, disable it and render it as a label instead
			cImGuiLabelData labelData;
			labelData.mFont.SetFile("sansation_large_bold.fnt");
			labelData.mFont.mvSize = cVector2f(36, 36);
			labelData.mFont.mColor = kDisabledColor;

			ImGui_DoLabelExt("Continue",labelData, OptionMenu_GetTopLeftOffset(kMainMenuButtonPos, 1.0));
		}

		/////////////////
		// New Game
		{
			if(OptionMenu_ButtonMainMenu("NewGame", kMainMenuButtonPos, 1, msSelectedMainMenuButton, mlClickedMainMenuButton))
			{
				mlClickedMainMenuButton = 1;
			}
			
			msSelectedMainMenuButton = OptionMenu_UpdateFocus("NewGame", msSelectedMainMenuButton);
		}

		/////////////////
		// Load Game
		{
			if (mbSaveLoadEnabled == false)
			{
			}
			else if(mbCanContinue)
			{
				if(OptionMenu_ButtonMainMenu("LoadGame", kMainMenuButtonPos, 2, msSelectedMainMenuButton, mlClickedMainMenuButton))
				{
					mlClickedMainMenuButton = 2;
				}
			
				msSelectedMainMenuButton = OptionMenu_UpdateFocus("LoadGame", msSelectedMainMenuButton);
			}
			else
			{
				//////////////
				// No games to load
				cImGuiLabelData labelData;
				labelData.mFont.SetFile("sansation_large_bold.fnt");
				labelData.mFont.mvSize = cVector2f(36, 36);
				labelData.mFont.mColor = kDisabledColor;

				ImGui_DoLabelExt("LoadGame",labelData, OptionMenu_GetTopLeftOffset(kMainMenuButtonPos + cVector2f(0, kOptionMenu_ButtonSpacing * 2.0), 1.0));
			}
		}

		/////////////////
		// Options
		{
			if(OptionMenu_ButtonMainMenu("Options", kMainMenuButtonPos, 3, msSelectedMainMenuButton, mlClickedMainMenuButton))
			{
				mlClickedMainMenuButton = 3;
			}
		
			msSelectedMainMenuButton = OptionMenu_UpdateFocus("Options", msSelectedMainMenuButton);
		}

		/////////////////
		// Exit
		if(Platform_IsPS4() == false)
		{
			if(OptionMenu_ButtonMainMenu("Exit", kMainMenuButtonPos, 4, msSelectedMainMenuButton, mlClickedMainMenuButton))
			{
				mlClickedMainMenuButton = 4;
			}

			msSelectedMainMenuButton = OptionMenu_UpdateFocus("Exit", msSelectedMainMenuButton);
		}

		if(ImGui_TimerOver("ButtonClicked"))
		{
			/////////////////
			// After the delay, perform the button click
			ImGui_StopTimer("ButtonClicked");

			switch(mlClickedMainMenuButton)
			{
			case 0: 
				///////////
				// Load the last save
				ImGui_AddTimer("Continue", mfFadeLength);
				cSound_FadeOutAll(eSoundEntryType_WorldAll, 1.0f / mfFadeLength, false);
				Music_StopAll(mfFadeLength);
				Sound_Stop("MenuBGNoise", 2.0f);
				cLux_GetGuiHandler().SetGameHudInputFocus(false);
				return;

				//break;
			case 1:
				// New game

				if(mbCanContinue)
				{
					// Show message box to confirm
					mbShowNewGame = true;
					msFocusNextFrame = "No";
					msMessageBoxFocus = "No";
				}
				else
				{
					ClickNewGame();
				}
				break;
			case 2:
				// Load
				mCurrentGroup = eMainMenuGroup_LoadGame;
				break;
			case 3:
				// Open options and set focus
				mCurrentGroup = eMainMenuGroup_Options;

				msFocusNextFrame = msSelectedOptionsButton;

				break;
			case 4:
				// Exit
				mbShowExit = true;
				msFocusNextFrame = "No";
				msMessageBoxFocus = "No";
				break;
			}

			mlClickedMainMenuButton = -1;
		}
		
		///////////
		// Show gamepad legacy
		OptionMenu_GamepadButtons(false);
	}

	//-------------------------------------------------------

	void GuiPauseMenuSelection()
	{
		/////////////////
		// Continue
		{
			if(OptionMenu_ButtonMainMenu("ReturnToGame", kMainMenuButtonPos,0, msSelectedPauseMenuButton, mlClickedPauseMenuButton))
			{
				mlClickedPauseMenuButton = 0;
			}

			msSelectedPauseMenuButton = OptionMenu_UpdateFocus("ReturnToGame", msSelectedPauseMenuButton);
		}

		/////////////////
		// Options
		{
			if(OptionMenu_ButtonMainMenu("Options", kMainMenuButtonPos, 1, msSelectedPauseMenuButton, mlClickedPauseMenuButton))
			{
				mlClickedPauseMenuButton = 1;
			}
		
			msSelectedPauseMenuButton = OptionMenu_UpdateFocus("Options", msSelectedPauseMenuButton);
		}

		

		/////////////////
		// Exit
		{
			if(OptionMenu_ButtonMainMenu("Exit", kMainMenuButtonPos, 2, msSelectedPauseMenuButton, mlClickedPauseMenuButton))
			{
				mlClickedPauseMenuButton = 2;
			}

			msSelectedPauseMenuButton = OptionMenu_UpdateFocus("Exit", msSelectedPauseMenuButton);
		}
		
		/////////////////
		// Save and exit
		if (mbSaveLoadEnabled == false)
		{
		}
		else if ( (Map_IsChanging()==false)&&(cScript_GetGlobalVarBool("InIntro")==false) )
		{
			if(OptionMenu_ButtonMainMenu("SaveAndExit", kMainMenuButtonPos, 3, msSelectedPauseMenuButton, mlClickedPauseMenuButton))
			{
				mlClickedPauseMenuButton = 3;
			}

			msSelectedPauseMenuButton = OptionMenu_UpdateFocus("SaveAndExit", msSelectedPauseMenuButton);
		}
		else
		{
			//////////////
			// Not possible to save and exit, disable it and render it as a label instead
			cImGuiLabelData labelData;
			labelData.mFont.SetFile("sansation_large_bold.fnt");
			labelData.mFont.mvSize = cVector2f(36, 36);
			labelData.mFont.mColor = kDisabledColor;

			ImGui_DoLabelExt("SaveAndExit",labelData, OptionMenu_GetTopLeftOffset(kMainMenuButtonPos+ cVector2f(0, kOptionMenu_ButtonSpacing * 3.0f), 1.0));
		}

		//////////////
		// Show playgo?
		int lETA = 0;
		if(cLux_IsPlayGoReady(lETA) == false && cScript_GetGlobalVarBool("PlayGo"))
		{
			//////////////
			// Display text telling the player that they cant progress yet
			float fPulse = ImGui_FadeOscillateFloat("PlayGoPulse", 1, 0.8f, 1.5);
			cImGuiLabelData labelData;
			labelData.mFont.SetFile("sansation_xlarge_bold.fnt");
			labelData.mFont.mvSize = cVector2f(36, 36);
			labelData.mFont.mColor = cColor(fPulse,fPulse);
			labelData.mFontAlign = eFontAlign_Center;
			
			ImGui_DoLabelExt("PlayGoInstructions",labelData, OptionMenu_GetTopLeftOffset(kMainMenuButtonPos - cVector2f(0, 100), 1.0), cVector2f(1000, 32));

			///////////////
			// Time left to progress
			tString sCat = ImGui_GetTransCategory();
			ImGui_SetTransCategory("");

			int lSeconds = lETA % 60;
			int lMinutes = (lETA / 60) % 60;
			int lHour = (lETA / 3600);

			tString sTime;

			if(lHour > 9) sTime += lHour + ":";
			else if(lHour > 0) sTime += "0"+lHour + ":";
			
			if(lMinutes > 9) sTime += lMinutes + ":";
			else if(lMinutes > 0) sTime += "0"+lMinutes + ":";

			if(lSeconds > 9) sTime += lSeconds;
			else if(lSeconds > 0) sTime += "0"+lSeconds;

			ImGui_DoLabelExt(sTime,labelData, OptionMenu_GetTopLeftOffset(kMainMenuButtonPos - cVector2f(0, 64), 1.0), cVector2f(1000, 32));
			ImGui_SetTransCategory(sCat);
		}

		if(ImGui_ActionTriggered(eImGuiAction_Cancel, true))
		{
				/////////////
				// Disable menu
				SetMenuActive(false);
				return;
		}

		if(ImGui_TimerOver("ButtonClicked"))
		{
			/////////////////
			// After the delay, perform the button click
			ImGui_StopTimer("ButtonClicked");

			switch(mlClickedPauseMenuButton)
			{
			case 0: 
				// return to game
				SetMenuActive(false);
				break;
			case 1:
				// Options
				mCurrentGroup = eMainMenuGroup_Options;

				msFocusNextFrame = msSelectedOptionsButton;
				break;
			case 3:
				mbSaveAndExit = true;
			case 2:
				// Exit
				mbShowExit = true;
				msFocusNextFrame = "No";
				msMessageBoxFocus = "No";
				break;
			}

			mlClickedPauseMenuButton = -1;
		}
		
		///////////
		// Show gamepad legacy
		OptionMenu_GamepadButtons(false);

	}
	
	//-------------------------------------------------------
	
	void GuiOptions()
	{
		////////////////////////////////////
		// Options background
		
		////////////////
		// Title
		OptionMenu_SectionTitle("Options", kOptionsBgPos, kOptionsBgSize);
		
		ImGui_DrawFrame(mGfxFrame, OptionMenu_GetTopLeftOffset(kOptionsBgPos, 0.0), OptionMenu_GetScaledSize(kOptionsBgSize));
		
		/////////////////
		// Gameplay
		{
			if(OptionMenu_ButtonOptions("Gameplay", kMainMenuButtonPos, 0, msSelectedOptionsButton))
			{
				mCurrentGroup = eMainMenuGroup_Options_Gameplay;
				msFocusNextFrame = msSelectedGameplayButton;
			}

			msSelectedOptionsButton = OptionMenu_UpdateFocus("Gameplay", msSelectedOptionsButton);
		}

		/////////////////
		// Controls
		{
			if(OptionMenu_ButtonOptions("Controls", kMainMenuButtonPos, 1, msSelectedOptionsButton))
			{
				mCurrentGroup = eMainMenuGroup_Options_Input;
				msFocusNextFrame = msSelectedInputButton;
			}

			msSelectedOptionsButton = OptionMenu_UpdateFocus("Controls", msSelectedOptionsButton);
		}

		/////////////////
		// Video
		if(Platform_IsPS4() == false)
		{
			if(OptionMenu_ButtonOptions("Video", kMainMenuButtonPos, 2, msSelectedOptionsButton))
			{
				mCurrentGroup = eMainMenuGroup_Options_Video;
				msFocusNextFrame = msSelectedVideoButton;
			}

			msSelectedOptionsButton = OptionMenu_UpdateFocus("Video", msSelectedOptionsButton);
		}
		else
		{
			if(OptionMenu_ButtonOptions("Gamma", kMainMenuButtonPos, 2, msSelectedOptionsButton))
			{
				mbShowingGammaMenu = true;
				/*if(mbMainMenuActive)
				{
					mCurrentGroup = eMainMenuGroup_Main;
					msFocusNextFrame = "Gamma";
					mlCurrentOptionChange = mlOptionChanges;
				}
				else*/
				{
					mCurrentGroup = eMainMenuGroup_Options_Video_Gamma;
					msFocusNextFrame = msSelectedVideoGammaButton;
				}
			}

			msSelectedOptionsButton = OptionMenu_UpdateFocus("Gamma", msSelectedOptionsButton);
		}
		
		/////////////////
		// Audio
		{
			if(OptionMenu_ButtonOptions("Audio", kMainMenuButtonPos, 3, msSelectedOptionsButton))
			{
				mCurrentGroup = eMainMenuGroup_Options_Audio;
				msFocusNextFrame = msSelectedAudioButton;
			}

			msSelectedOptionsButton = OptionMenu_UpdateFocus("Audio", msSelectedOptionsButton);
		}
		
		/////////////////
		// Back
		{
			bool bButton = OptionMenu_ButtonOptions("Back", kMainMenuButtonPos, 5, msSelectedOptionsButton);
			bool bGamepad = ImGui_ActionTriggered(eImGuiAction_Cancel, true);
			if(bButton || bGamepad)
			{
				mCurrentGroup = eMainMenuGroup_Main;
				msFocusNextFrame = mbMainMenuActive ? msSelectedMainMenuButton : msSelectedPauseMenuButton;

				////////
				// Reset menu pos
				if(bGamepad == false)
				{
					OptionMenu_GamepadButtons(false);
					msSelectedOptionsButton = "Video";					
					return;
				}
			}

			msSelectedOptionsButton = OptionMenu_UpdateFocus("Back", msSelectedOptionsButton);
		}
		
		///////////
		// Show gamepad legacy
		OptionMenu_GamepadButtons(false);
	}

	//-------------------------------------------------------

	void GuiStartGame()
	{
		//////////////////
		// Draw the save slots
		cVector2f vPos = kSaveSlotPos;
		vPos.x = (1280.0 / 2.0) * (720.0 / 1280.0) / (cGraphics_GetLowLevel().GetScreenSizeFloat().y / cGraphics_GetLowLevel().GetScreenSizeFloat().x); 
		float fSpacingMul = 2.0 * vPos.x / 1024.0;
		for(int i = 0; i < 5; ++i)
		{
			OptionMenu_SaveSlot("SaveSlot"+i, vPos + kSaveSlotSpacing * (i - 2.5 + (fSpacingMul - 1.0) / 2.0) * fSpacingMul, (i % 2) == 0 ? "gamma_background" : "", msSelectedStartButton, msSelectedStartButton);
		}

		/////////////////
		// Back
		{
			bool bButton = OptionMenu_ButtonOptions("Back", kMainMenuButtonPos, 8, msSelectedStartButton);
			bool bGamepad = ImGui_ActionTriggered(eImGuiAction_Cancel, true);

			if(bButton || bGamepad)
			{
				mCurrentGroup = eMainMenuGroup_Main;

				msFocusNextFrame = msSelectedMainMenuButton;
				ApplySettings();

				//////////
				// Reset menu pos
				if(bGamepad == false)
				{
					OptionMenu_GamepadButtons(msSelectedStartButton != "Back");
					return;
				}
			}
			
			msSelectedStartButton = OptionMenu_UpdateFocus("Back", msSelectedStartButton);
		}

		///////////
		// Show gamepad legacy
		OptionMenu_GamepadButtons(msSelectedStartButton != "Back");
	}

	//-------------------------------------------------------
	
	void GuiLoadGame()
	{
		
		////////////////////////////////////
		// Options background
		
		ImGui_DrawFrame(mGfxFrame, OptionMenu_GetTopLeftOffset(kOptionsBgPos, 0.0), OptionMenu_GetScaledSize(kLoadWindowBgSize));
		
		cImGuiGfx gfx;
		ImGui_DrawGfx(gfx, OptionMenu_GetTopLeftOffset(kLoadBgPos, 0.01), OptionMenu_GetScaledSize(kLoadBgSize), cColor(0.0, 1.0));
		
		////////////////
		// Title
		OptionMenu_SectionTitle("LoadGame", kOptionsBgPos, kLoadWindowBgSize);
		
		//////////////
		// Catch input
		int lActionVertical = 0;
		bool bMouseDown = false;
		float fPadding = mbScrollingSaveList ? 10000 : 5;
		
		int lMaxShownItems = 10;
		
		//////////////////////////////////////////
		// Possible values for lActionVertical:
		// 0:	nothing to do
		// -1:	moves focus up one entry
		// -2:	moves list up by one entry
		// +1:	moves focus down one entry
		// +2:	moves list down one entry
		if(mbShowLoadGame == false)
		{
			if(ImGui_ActionTriggered(eImGuiAction_Down, true)) lActionVertical++;
			if(ImGui_ActionTriggered(eImGuiAction_Up, true)) lActionVertical--;
			if(ImGui_ActionTriggered(eImGuiAction_ScrollDown, true) && (mlSaveFileOffset + mlSelectedLoadButton) < mvSaveNames.size()-1 && mlSelectedLoadButton != lMaxShownItems) lActionVertical+=2;
			if(ImGui_ActionTriggered(eImGuiAction_ScrollUp, true) && (mlSaveFileOffset + mlSelectedLoadButton) > 0 && mlSelectedLoadButton != lMaxShownItems) lActionVertical-=2;
			bMouseDown = ImGui_ActionIsDown(eImGuiAction_MouseLeft, false);
		}

		////////////////
		// Draw a list of all save files
		int c = 0;
			
		for(int i=mlSaveFileOffset; i<mvSaveNames.size() && c<lMaxShownItems; ++i)
		{
			tWString sDisplayedName = mvSaveNames[i];
			int lSubPos =cString_GetFirstStringPosW(sDisplayedName, tWString("AutoSave"));
			if(lSubPos>=0)
			{
				sDisplayedName = cString_SubW(sDisplayedName, lSubPos+8, -1);
			}
			
			if(OptionMenu_ButtonSaveFile("Save"+c, sDisplayedName, mvSaveDates[i], kLoadBgPos + cVector2f(26, c * kLoadSpacing),
																				   kLoadBgPos + cVector2f(590, c * kLoadSpacing+5), mlSelectedLoadButton == c))
			{
				if(bMouseDown == false || OptionMenu_GetMouseInside(kLoadScrollPos - cVector2f(fPadding, 0), 
																	kLoadScrollPos + kLoadScrollSize + cVector2f(10000, 0)).y == -1)
				{
					mlSaveFileToLoad = i;
					mbShowLoadGame = true;
					msMessageBoxFocus = "No";
					msFocusNextFrame="No";
				}
			}

			if(bMouseDown == false)
			{
				if (ImGui_PrevBecameInFocus())
				{
					mlSelectedLoadButton = c;
				}
			}
			c++;
		}
		
		//////////////
		// Update focus
		if(lActionVertical != 0)
		{
			//////////
			// Select file
			if(lActionVertical<0)	// Scroll up
			{
				if(lActionVertical==-1)
				{
					if (mlSelectedLoadButton==lMaxShownItems)	// Back button
					{
						mlSelectedLoadButton = cMath_Min(mvSaveNames.size() - 1, lMaxShownItems-1);
					}
					else
					{
						mlSelectedLoadButton--;
						if(mlSelectedLoadButton < 0)
						{
							if(mlSaveFileOffset > 0) 
							{
								mlSelectedLoadButton = 0;
								mlSaveFileOffset--;
							}
							else
							{
								mlSelectedLoadButton = lMaxShownItems;
							}
						}
					}
				}
				else
				{
					// Scrolling with Wheel
					if(mlSaveFileOffset > 0) 
					{
						mlSaveFileOffset--;
					}
				}
			}
			else	// Scroll down
			{
				if(lActionVertical==1)
				{
					if (mlSelectedLoadButton==lMaxShownItems)	// Back button
					{
						mlSelectedLoadButton = 0;
					}
					else
					{
						mlSelectedLoadButton++;
						if(mlSelectedLoadButton >= cMath_Min(mvSaveNames.size(),lMaxShownItems) )
						{
							if(mlSaveFileOffset<mvSaveNames.size()-lMaxShownItems) 
							{
								mlSelectedLoadButton--;
								mlSaveFileOffset++;
							}
							else
							{
								///////////
								// No more files, scroll to back button
								mlSelectedLoadButton = lMaxShownItems;
							}
						}
					}
				}
				else
				{
					// Scrolling with Wheel
					if(mlSaveFileOffset<mvSaveNames.size()-lMaxShownItems) 
					{
						mlSaveFileOffset++;
					}
				}
			}
			
		}

		//////////////
		// Scroll bar
		if(mvSaveNames.size() > lMaxShownItems)
		{
			////////////
			// Update input
			float fFiles = mvSaveNames.size();
			int lOldOffset = mlSaveFileOffset;
			float fMouseScrollY = OptionMenu_GetMouseInside(kLoadScrollPos - cVector2f(fPadding, 0), kLoadScrollPos + kLoadScrollSize + cVector2f(fPadding, 0)).y;

			if(fMouseScrollY != -1.0)
			{
				///////////
				// Mouse touching scroll, check if button pressed
				if(bMouseDown)
				{
					mlSaveFileOffset = cMath_RoundToInt((fFiles-lMaxShownItems) * fMouseScrollY);
					mbScrollingSaveList = true;
				}
			}

			if(bMouseDown == false)
			{
				////////
				// Stopped scrolling
				mbScrollingSaveList = false;
			}

			mlSaveFileOffset = cMath_Clamp(mlSaveFileOffset, 0, mvSaveNames.size() - lMaxShownItems);

			if(mlSelectedLoadButton >= 0 && mlSelectedLoadButton < 10 && (mlSaveFileOffset - lOldOffset) != 0)
			{
				int lDiff = (mlSaveFileOffset - lOldOffset);
				mlSelectedLoadButton = cMath_Clamp(mlSelectedLoadButton - lDiff, 0, 9);
			}

			float fScaleY = 1.0 - (fFiles - 10.0) / fFiles;
			float fPosY = 0;
			if (fFiles>lMaxShownItems)
				fPosY = (mlSaveFileOffset) / (fFiles-lMaxShownItems);
			ImGui_DrawGfx(gfx, OptionMenu_GetTopLeftOffset(kLoadScrollPos + kLoadScrollSize * cVector2f(0, (1.0 - fScaleY) * fPosY), 0.01), OptionMenu_GetScaledSize(kLoadScrollSize * cVector2f(1, fScaleY)), ((fMouseScrollY == -1.0f && mbScrollingSaveList == false) || mbShowLoadGame) ? kMainMenuButtonBgColor : cColor(1,1));
		}

		/////////////////
		// Back
		{
			bool bButton = OptionMenu_ButtonOptions("Back", kMainMenuButtonPos, 8, mlSelectedLoadButton < lMaxShownItems ? ("Save"+mlSelectedLoadButton) : "Back");
			bool bGamepad = ImGui_ActionTriggered(eImGuiAction_Cancel, true);
			if(bButton || bGamepad)
			{
				mCurrentGroup = eMainMenuGroup_Main;
				msFocusNextFrame = msSelectedMainMenuButton;

				////////
				// Reset menu pos
				if(bGamepad == false)
				{
					mlSelectedLoadButton = 0;
					OptionMenu_GamepadButtons(false);
				}

				return;
			}

			if(bMouseDown == false)
			{
				if (ImGui_PrevBecameInFocus())
				{
					//cLux_AddTodoMessage("Sound: Menu focus changed");
					Sound_PlayGui("special_fx/frontend/frontend_menu_focus", 1.0f, eSoundEntryType_Gui);
					mlSelectedLoadButton = lMaxShownItems;
				}
			}
		}

		///////////
		// Manual focus since we catch input
		if(mbShowLoadGame == false)
		{
			if(mlSelectedLoadButton >= 0 && mlSelectedLoadButton < 10) msFocusNextFrame = "Save"+mlSelectedLoadButton;
			else													   msFocusNextFrame = "Back";
		}

		///////////
		// Show gamepad legacy
		OptionMenu_GamepadButtons(false);
	}

	//-------------------------------------------------------
	
	void GuiOptionsInput()
	{
		if(Platform_IsPS4())
		{
			OptionMenu_UpdateExtraWidth("GamepadSens", false);
			OptionMenu_UpdateExtraWidth("InvertGamepadY", true);
			OptionMenu_UpdateExtraWidth("PadVibration", true);
			OptionMenu_UpdateExtraButtonWidth_Toggle();
		}
		
		////////////////////////////////////
		// Options background
		cVector2f vSize = Platform_IsPS4() ? kInputGamepadBgSize : kInputBgSize;
		
		ImGui_DrawFrame(mGfxFrame, OptionMenu_GetTopLeftOffset(kOptionsBgPos, 0.0), OptionMenu_GetScaledSize(vSize+cVector2f(OptionMenu_GetExtraWidth(), 0)));
		
		////////////////
		// Title
		OptionMenu_SectionTitle("Controls", kOptionsBgPos, vSize);

		int lY = 0;

		if(Platform_IsPS4() == false)
		{
			/////////////////
			// Controls
			{
				if(OptionMenu_ButtonOptions("Keybind", kMainMenuButtonPos, lY++, msSelectedInputButton))
				{
					mCurrentGroup = eMainMenuGroup_Options_Input_Keybind;
					msFocusNextFrame = msSelectedInputButton;
					mbKeybindChanged = false;
					mbBindingGamepad = false;
					mKeyBindBackDest = eMainMenuGroup_Options_Input;
					msKeyBindBackFocus = msSelectedInputButton;
					
					mpKeyConfig.Save();
				}

				msSelectedInputButton = OptionMenu_UpdateFocus("Keybind", msSelectedInputButton);
			}
			
			/////////////////
			// Mouse options
			{
				if(OptionMenu_ButtonOptions("MouseOptions", kMainMenuButtonPos, lY++, msSelectedInputButton))
				{
					mCurrentGroup = eMainMenuGroup_Options_Input_Mouse;
					msFocusNextFrame = msSelectedInputMouseButton;
					mpKeyConfig.Save();
				}

				msSelectedInputButton = OptionMenu_UpdateFocus("MouseOptions", msSelectedInputButton);
			}
			
			/////////////////
			// Gamepad options
			{
				if(OptionMenu_ButtonOptions("GamepadOptions", kMainMenuButtonPos, lY++, msSelectedInputButton))
				{
					mCurrentGroup = eMainMenuGroup_Options_Input_Gamepad;
					msFocusNextFrame = msSelectedInputGamepadButton;
					mpKeyConfig.Save();
				}

				msSelectedInputButton = OptionMenu_UpdateFocus("GamepadOptions", msSelectedInputButton);
			}
		}
		else
		{
			// For PS4, show gamepad options
			GuiOptionsInputGamepadContents(lY, lY, eMainMenuGroup_Options_Input, msSelectedInputButton, msSelectedInputButton);
		}
		
		/////////////////
		// Back
		{
			bool bButton = OptionMenu_ButtonOptions("Back", kMainMenuButtonPos, lY + 1, msSelectedInputButton);
			bool bGamepad = ImGui_ActionTriggered(eImGuiAction_Cancel, true);

			if(bButton || bGamepad)
			{
				mCurrentGroup = eMainMenuGroup_Options;

				msFocusNextFrame = msSelectedOptionsButton;
				ApplySettings();

				//////////
				// Reset menu pos
				if(bGamepad == false)
				{
					OptionMenu_GamepadButtons(false);
					msSelectedInputButton = "Keybind";
					return;
				}
			}
			
			msSelectedInputButton = OptionMenu_UpdateFocus("Back", msSelectedInputButton);
		}

		///////////
		// Show gamepad legacy
		OptionMenu_GamepadButtons(false);
	}
	
	//-------------------------------------------------------
	
	void GuiOptionsInputMouse()
	{
		//////////////////////////////////////////////////
		// Check if extra width needed for translations
		{
			OptionMenu_UpdateExtraWidth("MouseSens", false);
			OptionMenu_UpdateExtraWidth("InvertMouseY", true);
			OptionMenu_UpdateExtraWidth("SmoothMouse", true);
			OptionMenu_UpdateExtraButtonWidth_Toggle();
		}
		
		////////////////////////////////////
		// Options background
		cVector2f vSize = kInputBgSize;
		
		ImGui_DrawFrame(mGfxFrame, OptionMenu_GetTopLeftOffset(kOptionsBgPos, 0.0), OptionMenu_GetScaledSize(vSize+cVector2f(OptionMenu_GetExtraWidth(), 0)));
		
		////////////////
		// Title
		OptionMenu_SectionTitle("MouseOptions", kOptionsBgPos, vSize);

		int lY = 0;

		/////////////////
		// Mouse sensitivity
		{
			float fValue = mpConfig.GetFloat("Input", "MouseSensitivity", 1.0f);
			fValue -= 0.01f;
			fValue /= 4.0f;
			fValue = OptionMenu_ButtonOptionsSlider("MouseSens", kMainMenuButtonPos, lY++, msSelectedInputMouseButton, fValue, 0.2f / 4.0f, mlActionHorizontal, "");
			fValue *= 4.0f;
			fValue += 0.01f;
			mpConfig.SetFloat("Input", "MouseSensitivity", fValue);

			msSelectedInputMouseButton = OptionMenu_UpdateFocus("MouseSens", msSelectedInputMouseButton);
		}
		
		/////////////////
		// Invert Mouse Y
		{
			bool bValue = mpConfig.GetBool("Input", "InvertMouse", false);
			bValue = OptionMenu_ButtonOptionsToggle("InvertMouseY", kMainMenuButtonPos, lY++, msSelectedInputMouseButton, bValue, mlActionHorizontal);
			mpConfig.SetBool("Input", "InvertMouse", bValue);

			msSelectedInputMouseButton = OptionMenu_UpdateFocus("InvertMouseY", msSelectedInputMouseButton);
		}
		
		/////////////////
		// Smooth mouse
		{
			bool bValue = mpConfig.GetBool("Input", "SmoothMouse", true);
			bValue = OptionMenu_ButtonOptionsToggle("SmoothMouse", kMainMenuButtonPos, lY++, msSelectedInputMouseButton, bValue, mlActionHorizontal);
			mpConfig.SetBool("Input", "SmoothMouse", bValue);
			msSelectedInputMouseButton = OptionMenu_UpdateFocus("SmoothMouse", msSelectedInputMouseButton);
		}
		
		/////////////////
		// Back
		{
			bool bButton = OptionMenu_ButtonOptions("Back", kMainMenuButtonPos, lY + 1, msSelectedInputMouseButton);
			bool bGamepad = ImGui_ActionTriggered(eImGuiAction_Cancel, true);

			if(bButton || bGamepad)
			{
				mCurrentGroup = eMainMenuGroup_Options_Input;

				msFocusNextFrame = msSelectedInputButton;
				ApplySettings();

				//////////
				// Reset menu pos
				if(bGamepad == false)
				{
					OptionMenu_GamepadButtons(msSelectedInputMouseButton != "Back");
					msSelectedInputMouseButton = "MouseSens";
					return;
				}
			}
			
			msSelectedInputMouseButton = OptionMenu_UpdateFocus("Back", msSelectedInputMouseButton);
		}

		///////////
		// Show gamepad legacy
		OptionMenu_GamepadButtons(msSelectedInputMouseButton != "Back");
	}
	
	//-------------------------------------------------------
	
	eMainMenuGroup mGamepadMappingBackDest = eMainMenuGroup_Options_Input_Gamepad;
	void GuiOptionsInputGamepadContents(const int &in alInY, int &out alOutY, eMainMenuGroup aMappingBackDest, const tString &in asInSelectedButton, tString &out asOutSelectedButton)
	{
		int lY = alInY;
		
		asOutSelectedButton = asInSelectedButton;
		
		mGamepadMappingBackDest = aMappingBackDest;
		/////////////////
		// Mapping
		{
			if(OptionMenu_ButtonOptions("GamepadMapping", kMainMenuButtonPos, lY++, asOutSelectedButton))
			{
				mCurrentGroup = eMainMenuGroup_Options_Input_GamepadMapping;
				msFocusNextFrame = "Back";
				mpKeyConfig.Save();
			}

			asOutSelectedButton = OptionMenu_UpdateFocus("GamepadMapping", asOutSelectedButton);
		}
		
		/////////////////
		// Gamepad Sens
		{
			float fValue = mpConfig.GetFloat("Input", "GamepadSensitivity", 2.0f);
			fValue -= 0.01f;
			fValue /= 5.0f;
			fValue = OptionMenu_ButtonOptionsSlider("GamepadSens", kMainMenuButtonPos, lY++, asOutSelectedButton, fValue, 0.2f / 5.0f, mlActionHorizontal, "");
			fValue *= 5.0f;
			fValue += 0.01f;
			mpConfig.SetFloat("Input", "GamepadSensitivity", fValue);

			asOutSelectedButton = OptionMenu_UpdateFocus("GamepadSens", asOutSelectedButton);
		}

		/////////////////
		// Invert Pad Y
		{
			bool bValue = mpConfig.GetBool("Input", "InvertPad", false);
			bValue = OptionMenu_ButtonOptionsToggle("InvertGamepadY", kMainMenuButtonPos, lY++, asOutSelectedButton, bValue, mlActionHorizontal);
			mpConfig.SetBool("Input", "InvertPad", bValue);

			asOutSelectedButton = OptionMenu_UpdateFocus("InvertGamepadY", asOutSelectedButton);
		}
		
		/////////////////
		// Pad vibration
		{
			bool bValue = mpConfig.GetBool("Input", "Rumble", true);
			bValue = OptionMenu_ButtonOptionsToggle("PadVibration", kMainMenuButtonPos, lY++, asOutSelectedButton, bValue, mlActionHorizontal);
			mpConfig.SetBool("Input", "Rumble", bValue);

			asOutSelectedButton = OptionMenu_UpdateFocus("PadVibration", asOutSelectedButton);
		}
		
		alOutY = lY;
	}
	
	void GuiOptionsInputGamepad()
	{
		//////////////////////////////////////////////////
		// Check if extra width needed for translations
		{
			OptionMenu_UpdateExtraWidth("GamepadSens", false);
			OptionMenu_UpdateExtraWidth("InvertGamepadY", true);
			OptionMenu_UpdateExtraWidth("PadVibration", true);
			OptionMenu_UpdateExtraButtonWidth_Toggle();
		}
		
		////////////////////////////////////
		// Options background
		cVector2f vSize = kInputGamepadBgSize;
		
		ImGui_DrawFrame(mGfxFrame, OptionMenu_GetTopLeftOffset(kOptionsBgPos, 0.0), OptionMenu_GetScaledSize(vSize + cVector2f(OptionMenu_GetExtraWidth(), 0)));
		
		////////////////
		// Title
		OptionMenu_SectionTitle("GamepadOptions", kOptionsBgPos, vSize);

		int lY = 0;

		GuiOptionsInputGamepadContents(lY, lY, eMainMenuGroup_Options_Input_Gamepad, msSelectedInputGamepadButton, msSelectedInputGamepadButton);
		
		
		bool bShowGamepadButtonArrows = msSelectedInputGamepadButton != "Back" && msSelectedInputGamepadButton != "GamepadMapping";
		/////////////////
		// Back
		{
			bool bButton = OptionMenu_ButtonOptions("Back", kMainMenuButtonPos, lY + 1, msSelectedInputGamepadButton);
			bool bGamepad = ImGui_ActionTriggered(eImGuiAction_Cancel, true);


			if(bButton || bGamepad)
			{
				mCurrentGroup = eMainMenuGroup_Options_Input;

				msFocusNextFrame = msSelectedInputButton;
				ApplySettings();

				//////////
				// Reset menu pos
				if(bGamepad == false)
				{
					OptionMenu_GamepadButtons(bShowGamepadButtonArrows);
					msSelectedInputGamepadButton = "GamepadMapping";
					return;
				}
			}
			
			msSelectedInputGamepadButton = OptionMenu_UpdateFocus("Back", msSelectedInputGamepadButton);
		}

		///////////
		// Show gamepad legacy
		OptionMenu_GamepadButtons(bShowGamepadButtonArrows);
	}

	//-------------------------------------------------------
	
	tString ParseKeybind(tString asBind, bool abAnalog)
	{
		if(asBind.length() > 0)
		{
			int lPos = cString_GetFirstCharPos(asBind, '.');

			if(lPos != -1)
			{
				tString sType = cString_Sub(asBind, 0, lPos);

				if(sType == "Gamepad")
				{
					if(abAnalog)
					{
						tString sAxisNum = cString_Sub(asBind, lPos+8);
						sAxisNum = cString_Sub(sAxisNum, 0, cString_GetFirstCharPos(sAxisNum, '.'));
						int lAxis = cString_ToInt(sAxisNum, 0);

						return "Stick."+(lAxis / 2);
					}
					else
					{
						tString sKey = cString_Sub(asBind, lPos+3);

						return sKey;
					}
				}
				else
				{
					tString sKey = cString_Sub(asBind, lPos+1);

					return sKey;					
				}
			}
		}

		return asBind;
	}
	
	eMainMenuGroup mKeyBindBackDest = eMainMenuGroup_Options_Input;
	tString msKeyBindBackFocus = msSelectedInputButton;
	void GuiOptionsInputKeybind()
	{			
		////////////////
		// Select which type to bind
		array<cBindableAction> vActions = mbBindingGamepad ? mvGamepadActions : mvActions;
		tString sMain = mbBindingGamepad ? "GamepadPrimary" : "Primary";
		tString sSec = mbBindingGamepad ? "GamepadSecondary" : "Secondary";
		
		ImGui_SetTransCategory("Actions"); 
		for(uint i = 0; i < vActions.size(); ++i)
		{
			OptionMenu_UpdateExtraWidth(vActions[i].msAction, false);
		}	
		
		////////////////////////////////////
		// Options background
		cImGuiGfx gfx;
		ImGui_DrawGfx(gfx, OptionMenu_GetTopLeftOffset(kKeybindBgPos, 0.01), OptionMenu_GetScaledSize(kKeybindBgSize + cVector2f(OptionMenu_GetExtraWidth(), 0)), cColor(0.0, 1.0));
		
		ImGui_DrawFrame(mGfxFrame, OptionMenu_GetTopLeftOffset(kOptionsBgPos, 0.0), OptionMenu_GetScaledSize(kKeybindWindowBgSize + cVector2f(OptionMenu_GetExtraWidth(), 0)));

		////////////////
		// Get any duplicates
		array<bool> vDuplicates0;
		array<bool> vDuplicates1;
		bool bHasDuplicates = false;

		for(uint i = 0; i < vActions.size(); ++i)
		{
			//////////////
			// Check if this is a duplicate
			bool bDuplicate0 = false;
			bool bDuplicate1 = false;
			
			tString sBind = vActions[i].msAction;
			tString sPrimary = mpKeyConfig.GetString(sBind, sMain, "");
			tString sSecondary = mpKeyConfig.GetString(sBind, sSec, "");
			
			bool bCheck0 = sPrimary.length() != 0;
			bool bCheck1 = sSecondary.length() != 0;

			if(bCheck0 || bCheck1)
			{
				if(sSecondary == sPrimary)
				{
					bDuplicate0 = true;
					bDuplicate1 = true;
				}

				for(uint j = 0; j < vActions.size(); ++j)
				{
					if(i == j) continue;

					sBind = vActions[j].msAction;

					tString sComp0 = mpKeyConfig.GetString(sBind, sMain, "");
					tString sComp1 = mpKeyConfig.GetString(sBind, sSec, "");
					
					if(bCheck0 && (sComp0 == sPrimary || sComp1 == sPrimary)) bDuplicate0 = true;
					if(bCheck1 && (sComp0 == sSecondary || sComp1 == sSecondary)) bDuplicate1 = true;

					if((bCheck0 == false || bDuplicate0) && (bCheck1 == false || bDuplicate1)) break;
				}
			}
			
			vDuplicates0.push_back(bDuplicate0);
			vDuplicates1.push_back(bDuplicate1);
			if(bDuplicate0 || bDuplicate1) bHasDuplicates = true;
		}


		//////////////
		// Catch input
		int lActionVertical = 0;
		bool bMouseDown = false;
		float fPadding = mbScrollingKeybindList ? 10000 : 5;
		int lNumBinds = 9;

		if(mlActionToBind == 0 && mbShowApplyKeyChanges == false && mbShowReset == false)
		{
			if(ImGui_ActionTriggered(eImGuiAction_Down, true)) lActionVertical++;
			if(ImGui_ActionTriggered(eImGuiAction_Up, true)) lActionVertical--;
			if(ImGui_ActionTriggered(eImGuiAction_ScrollDown, true) && (mlKeybindOffset + mlSelectedKeybindButton) < vActions.size()-1 && mlSelectedKeybindButton != lNumBinds) lActionVertical++;
			if(ImGui_ActionTriggered(eImGuiAction_ScrollUp, true) && (mlKeybindOffset + mlSelectedKeybindButton) > 0 && mlSelectedKeybindButton != lNumBinds) lActionVertical--;
			bMouseDown = ImGui_ActionIsDown(eImGuiAction_MouseLeft, false);
		}

		////////////////
		// Draw a list of all keybinds
		int c = 0;
			
		for(int i = mlKeybindOffset; i < vActions.size() && c < lNumBinds; ++i)
		{
			///////////////
			// Get action and parse the bind
			tString sBind = vActions[i].msAction;

			tString sPrimary = ParseKeybind(mpKeyConfig.GetString(sBind, sMain, ""), vActions[i].mbAnalog);
			tString sSecondary = ParseKeybind(mpKeyConfig.GetString(sBind, sSec, ""), vActions[i].mbAnalog);

			///////////////
			// Draw button, use red color if a duplicate is detected
			cColor color0 = vDuplicates0[i] ? cColor(1, 0, 0, 1) : cColor(0,1);
			cColor color1 = vDuplicates1[i] ? cColor(1, 0, 0, 1) : cColor(0,1);
			int lFocusChange = 0;
			int lButton = OptionMenu_ButtonKeybind("Bind"+c, sBind, sPrimary, sSecondary, kKeybindBgPos + cVector2f(26, c * kKeybindSpacing), mlSelectedKeybindButton == c, mlKeybindFocusSlot, lFocusChange, color0, color1);
			
			if(bMouseDown == false)
			{
				if (lFocusChange > 0)
				{
					mlSelectedKeybindButton = c;
					mlKeybindFocusSlot = lFocusChange-1;
				}
			}

			if(lButton > 0 && mlKeybindFocusSlot > 0)
			{
				if(bMouseDown == false || OptionMenu_GetMouseInside(kKeybindScrollPos - cVector2f(fPadding, 0) + cVector2f(OptionMenu_GetExtraWidth(), 0), 
																	kKeybindScrollPos + kKeybindScrollSize + cVector2f(10000, 0)).y == -1)
				{
					mlActionToBind = i+1;
					msKeybindSlot = mlKeybindFocusSlot == 1 ? sMain : sSec;
					msFocusAfterBind = "Bind"+c + msKeybindSlot;
					msKeybindFirstState = "";
				}
			}
			c++;
		}
		
		//////////////
		// Update focus
		if(lActionVertical != 0)
		{
			//////////
			// Select file
			if (lActionVertical<0)	// Scroll up
			{
				if (mlSelectedKeybindButton==lNumBinds+1)	// Back button
				{
					mlSelectedKeybindButton = lNumBinds;
				}
				else if (mlSelectedKeybindButton==lNumBinds)
				{
					mlSelectedKeybindButton = lNumBinds-1;
				}
				else
				{
					mlSelectedKeybindButton--;
					if(mlSelectedKeybindButton < 0)
					{
						if(mlKeybindOffset > 0) 
						{
							mlSelectedKeybindButton = 0;
							mlKeybindOffset--;
						}
						else
						{
							mlSelectedKeybindButton = lNumBinds+1;
						}
					}
				}
			}
			else	// Scroll down
			{
				if (mlSelectedKeybindButton==lNumBinds)
				{
					mlSelectedKeybindButton = lNumBinds+1;
				}
				else if (mlSelectedKeybindButton==lNumBinds+1)	// Back button
				{
					mlSelectedKeybindButton = 0;
				}
				else
				{
					mlSelectedKeybindButton++;
					if(mlSelectedKeybindButton >= cMath_Min(vActions.size(),lNumBinds) )
					{
						if(mlKeybindOffset<vActions.size()-lNumBinds) 
						{
							mlSelectedKeybindButton--;
							mlKeybindOffset++;
						}
						else
						{
							///////////
							// No more files, scroll to back button
							mlSelectedKeybindButton = lNumBinds;
						}
					}
				}			
			}
		}
			
		//////////////
		// Left right focus
		if(mlActionHorizontal != 0 || lActionVertical!=0)
		{
			mlKeybindFocusSlot = cMath_Clamp(mlKeybindFocusSlot + mlActionHorizontal, 1, 2);
		}

		//////////////
		// Scroll bar
		if(vActions.size() > lNumBinds)
		{
			////////////
			// Update input
			float fFiles = vActions.size();
			int lOldOffset = mlKeybindOffset;
			float fMouseScrollY = OptionMenu_GetMouseInside(kKeybindScrollPos - cVector2f(fPadding, 0) + cVector2f(OptionMenu_GetExtraWidth(), 0), kKeybindScrollPos + kKeybindScrollSize + cVector2f(fPadding, 0) + cVector2f(OptionMenu_GetExtraWidth(), 0)).y;

			if(fMouseScrollY != -1.0)
			{
				///////////
				// Mouse touching scroll, check if button pressed
				if(bMouseDown)
				{
					mlKeybindOffset = cMath_RoundToInt((fFiles-9) * fMouseScrollY);
					mbScrollingKeybindList = true;
				}
			}

			if(bMouseDown == false)
			{
				////////
				// Stopped scrolling
				mbScrollingKeybindList = false;
			}

			mlKeybindOffset = cMath_Clamp(mlKeybindOffset, 0, vActions.size() - lNumBinds);

			if(mlSelectedKeybindButton >= 0 && mlSelectedKeybindButton < lNumBinds && (mlSaveFileOffset - lOldOffset) != 0)
			{
				int lDiff = (mlKeybindOffset - lOldOffset);
				mlSelectedKeybindButton = cMath_Clamp(mlSelectedKeybindButton - lDiff, 0, lNumBinds-1);
			}

			float fScaleY = 1.0 - (fFiles - lNumBinds) / fFiles;
			float fPosY = 0;
			if (fFiles>lNumBinds)
				fPosY = (mlKeybindOffset) / (fFiles-lNumBinds);
			ImGui_DrawGfx(gfx, OptionMenu_GetTopLeftOffset(kKeybindScrollPos + kKeybindScrollSize * cVector2f(0, (1.0 - fScaleY) * fPosY) + cVector2f(OptionMenu_GetExtraWidth(), 0), 0.01), OptionMenu_GetScaledSize(kKeybindScrollSize * cVector2f(1, fScaleY)), ((fMouseScrollY == -1.0f && mbScrollingKeybindList == false) || (mlActionToBind > 0 || mbShowApplyKeyChanges || mbShowReset)) ? kMainMenuButtonBgColor : cColor(1,1));
		}
		
		tString sSelected;
		if(mlSelectedKeybindButton < lNumBinds) sSelected = ("Bind"+mlSelectedKeybindButton);
		else if(mlSelectedKeybindButton == lNumBinds) sSelected = "ResetToDefault";
		else sSelected = "Back";
		
		/////////////////
		// Reset to default
		{
			if(OptionMenu_ButtonOptions("ResetToDefault", kMainMenuButtonPos+ cVector2f(0, 10), 7, sSelected))
			{
				mbShowReset = true;
				msFocusNextFrame = "No";
			}

			if(bMouseDown == false)
			{
				if (ImGui_PrevBecameInFocus())
				{
					//cLux_AddTodoMessage("Sound: Menu focus changed");
					Sound_PlayGui("special_fx/frontend/frontend_menu_focus", 1.0f, eSoundEntryType_Gui);
					mlSelectedKeybindButton = lNumBinds;
				}
			}
		}

		/////////////////
		// Back
		{
			bool bButton = OptionMenu_ButtonOptions("Back", kMainMenuButtonPos+ cVector2f(0, 10), 8, sSelected);
			bool bGamepad = ImGui_ActionTriggered(eImGuiAction_Cancel, true);
			if(bButton || bGamepad)
			{
				if(mbKeybindChanged == false)
				{
					mCurrentGroup = mKeyBindBackDest;
					msFocusNextFrame = msKeyBindBackFocus;
				}
				else
				{
					mbShowDuplicateKeys = bHasDuplicates;
					mbShowApplyKeyChanges = true;
					msFocusNextFrame = "No";
				}

				////////
				// Reset menu pos
				if(bGamepad == false)
				{
					mlSelectedKeybindButton = 0;
				}
				
				OptionMenu_GamepadButtons(true);
				return;
			}

			if(bMouseDown == false)
			{
				if (ImGui_PrevBecameInFocus())
				{
					//cLux_AddTodoMessage("Sound: Menu focus changed");
					Sound_PlayGui("special_fx/frontend/frontend_menu_focus", 1.0f, eSoundEntryType_Gui);
					mlSelectedKeybindButton = lNumBinds+1;
				}
			}
		}

		///////////
		// Manual focus since we catch input
		if(mlActionToBind == 0 && mbShowApplyKeyChanges == false && mbShowReset == false)
		{
			if(mlSelectedKeybindButton >= 0 && mlSelectedKeybindButton < lNumBinds)
			{
				if(mlKeybindFocusSlot == 0) msFocusNextFrame = "Bind"+mlSelectedKeybindButton;
				if(mlKeybindFocusSlot == 1) msFocusNextFrame = "Bind"+mlSelectedKeybindButton+"Primary";
				if(mlKeybindFocusSlot == 2) msFocusNextFrame = "Bind"+mlSelectedKeybindButton+"Secondary";
			}
			else if(mlSelectedKeybindButton == lNumBinds)
			{
				msFocusNextFrame = "ResetToDefault";				
			}
			else						
			{						 
				msFocusNextFrame = "Back";
			}
		}

		///////////
		// Show gamepad legacy
		OptionMenu_GamepadButtons(true);
		
		OptionMenu_ResetExtraWidth();
	}
	
	//-------------------------------------------------------
	
	tString msOldProfile;
	tString msOldPreset;
	void GuiOptionsInputMapping()
	{
		////////////////////////////////////
		// Options background
		ImGui_DrawFrame(mGfxFrame, OptionMenu_GetTopLeftOffset(kOptionsBgPos, 0.0), OptionMenu_GetScaledSize(kOptionsMappingBgSize));
		
		/////////////////
		// Draw preset
		tString sDefault = Platform_IsPS4() ? "PS4 Controller" : "X360 Controller";
		tString sProfile = mpKeyConfig.GetString("GamepadMapping", "Profile", sDefault);
		tString sPreset = mpKeyConfig.GetString("GamepadMapping", "Preset", "Right");
			
		/////////////
		// Check gamepad input
		if(ImGui_ActionTriggered(eImGuiAction_Down, true))
		{
			msSelectedInputMappingButton = "Back";
		}
		if(ImGui_ActionTriggered(eImGuiAction_Up, true))
		{
			//if(sProfile == "Custom") msSelectedInputMappingButton = "CustomPad";
			//else	
			msSelectedInputMappingButton = "Back";
		}
		if(mlActionHorizontal != 0)
		{
			msFocusNextFrame = msSelectedInputMappingButton = "Back";
		}
		
		if(ImGui_IsFading("PresetTransition"))
		{
			float fAlpha = ImGui_GetStateFloat("PresetTransition");
			GuiOptionsInputMappingGamepadProfile(sProfile, sPreset, fAlpha, false);
			GuiOptionsInputMappingGamepadProfile(msOldProfile, msOldPreset, 1.0f-(fAlpha*3.0f), false);
		}
		else
		{
			GuiOptionsInputMappingGamepadProfile(sProfile, sPreset, 1.0f, false);
		}
		
		/////////////////
		// Left and right buttons
		{
			////////////////
			// Get current selection
			int lId = 0;
			array<tString> vProfilePresets;
			
			if(Platform_IsPS4())
			{
				vProfilePresets.push_back("PS4 Controller"); vProfilePresets.push_back("Right");
				vProfilePresets.push_back("PS4 Controller"); vProfilePresets.push_back("Left");
			}
			else
			{
				vProfilePresets.push_back("X360 Controller"); vProfilePresets.push_back("Right");
				vProfilePresets.push_back("X360 Controller"); vProfilePresets.push_back("Left");
			}

			for(int i = 0; i < vProfilePresets.size(); i+=2)
			{
				if(vProfilePresets[i] == sProfile &&
				   vProfilePresets[i+1] == sPreset)
				{
					lId = i / 2;
					break;
				}
			}

			////////////////
			// Draw arrows
			cImGuiButtonData labelData;
			labelData.mbUseBackgroundGfx = false;
			labelData.mbUseInFocusGfx = false;
			labelData.mbUseTriggeredGfx = false;
				
			//msSelectedInputMappingButton = "Right";
			bool bArrowRightFading = ImGui_IsFading("PresetTransitionRight");
			if(lId > 0 || bArrowRightFading) //right arrow
			{
				/////////////
				// Draw arrow
				tString sArrowGfxFile = "startmenu_options_arrow";
				cColor color(1.0f, 1.0f);
				
				if(msSelectedInputMappingButton=="Right" || bArrowRightFading)
				{
					sArrowGfxFile += "_active";
					
					if(bArrowRightFading)
						color.a = ImGui_GetStateFloat("PresetTransitionRight");
				}
				else
				{
					sArrowGfxFile += "_inactive";
				}
				
				cImGuiGfx gfxArrow(sArrowGfxFile);
				
				//cColor color = msSelectedInputMappingButton == "Right" ? cColor(1,1) : cColor(0.5f,1);
				
				ImGui_SetModRotateAngle(180);
				ImGui_DrawGfx(gfxArrow, OptionMenu_GetTopLeftOffset(kMappingArrowPosRight, 2.0), OptionMenu_GetScaledSize(kMappingArrowSize), color);
				ImGui_SetModRotateAngle(0.0);

				// And button to click
				if(bArrowRightFading==false && ImGui_DoButtonExt("Right", "",labelData, OptionMenu_GetTopLeftOffset(kMappingButtonPosRight, 1.0), OptionMenu_GetScaledSize(kMappingButtonSize)) || mlActionHorizontal < 0)
				{	
					/////////////
					// Set next preset
					lId--;
					mpKeyConfig.SetString("GamepadMapping", "Profile", vProfilePresets[lId * 2]);
					mpKeyConfig.SetString("GamepadMapping", "Preset", vProfilePresets[lId * 2 + 1]);
					mbKeybindChanged = true;
					
					msOldProfile	= sProfile;
					msOldPreset		= sPreset;
					
					ImGui_SetStateFloat("PresetTransition", 0.0f);
					ImGui_FadeStateFloat("PresetTransition", 1.0f, 0.75f);
					
					ImGui_SetStateFloat("PresetTransitionRight", 1.0f);
					ImGui_FadeStateFloat("PresetTransitionRight", 0.0f, 0.5f);
				}

				if(mlActionHorizontal == 0) msSelectedInputMappingButton = OptionMenu_UpdateFocus("Right", msSelectedInputMappingButton);
			}

			bool bArrowLeftFading = ImGui_IsFading("PresetTransitionLeft");
			if(lId < vProfilePresets.size() / 2 - 1 || bArrowLeftFading)
			{
				/////////////
				// Draw arrow
				tString sArrowGfxFile = "startmenu_options_arrow";
				cColor color(1.0f, 1.0f);
				
				if(msSelectedInputMappingButton=="Left" || bArrowLeftFading)
				{
					sArrowGfxFile += "_active";
					
					if(bArrowLeftFading)
						color.a = ImGui_GetStateFloat("PresetTransitionLeft");
				}
				else
				{
					sArrowGfxFile += "_inactive";
				}
				
				cImGuiGfx gfxArrow(sArrowGfxFile);
				
				//cColor color = msSelectedInputMappingButton == "Left" ? cColor(1,1) : cColor(0.5f,1);
				ImGui_DrawGfx(gfxArrow, OptionMenu_GetTopLeftOffset(kMappingArrowPosLeft, 2.0), OptionMenu_GetScaledSize(kMappingArrowSize), color);

				// And button to click
				if(bArrowLeftFading==false && ImGui_DoButtonExt("Left", "",labelData, OptionMenu_GetTopLeftOffset(kMappingButtonPosLeft, 1.0), OptionMenu_GetScaledSize(kMappingButtonSize)) || mlActionHorizontal > 0)
				{
					/////////////
					// Set next preset
					lId++;
					mpKeyConfig.SetString("GamepadMapping", "Profile", vProfilePresets[lId * 2]);
					mpKeyConfig.SetString("GamepadMapping", "Preset", vProfilePresets[lId * 2 + 1]);
					mbKeybindChanged = true;
					
					msOldProfile	= sProfile;
					msOldPreset		= sPreset;
					
					ImGui_SetStateFloat("PresetTransition", 0.0f);
					ImGui_FadeStateFloat("PresetTransition", 1.0f, 0.75f);
					
					ImGui_SetStateFloat("PresetTransitionLeft", 1.0f);
					ImGui_FadeStateFloat("PresetTransitionLeft", 0.0f, 0.5f);
				}

				if(mlActionHorizontal == 0) msSelectedInputMappingButton = OptionMenu_UpdateFocus("Left", msSelectedInputMappingButton);
			}
		}

		/////////////////
		// Back
		{
			bool bButton = OptionMenu_ButtonOptions("Back", kMainMenuButtonPos, 8, msSelectedInputMappingButton);
			bool bGamepad = ImGui_ActionTriggered(eImGuiAction_Cancel, true);

			if(bButton || bGamepad)
			{
				if(mbKeybindChanged == false)
				{
					mCurrentGroup = mGamepadMappingBackDest;
					msFocusNextFrame = msSelectedInputButton;
				}
				else
				{
					mbShowApplyKeyChanges = true;
					msFocusNextFrame = "No";
				}

				//////////
				// Reset menu poos
				if(bGamepad == false)
				{
					OptionMenu_GamepadButtons(false);
					msSelectedInputMappingButton = "Back";
					return;
				}
			}

			msSelectedInputMappingButton = OptionMenu_UpdateFocus("Back", msSelectedInputMappingButton);
		}

		///////////
		// Show gamepad legacy
		OptionMenu_GamepadButtons(true);
	}
	
	cVector2f mvButtonPos, mvLabelPos;
	void GuiOptionsInputMappingGamepadProfile(const tString &in asProfile, const tString &in asPreset, float afAlpha, bool abFadeController)
	{
		cVector3f vReferencePos = OptionMenu_GetTopLeftOffset(kMappingPos, 1.0);
		cVector2f vFrameSize = OptionMenu_GetScaledSize(kMappingSize);
		
		cVector2f vControllerSize = vFrameSize;
		float fControllerAlpha = 0.3f;
		
		float fGfxHeight = vFrameSize.y*0.115f;
		float fEntrySeparation = fGfxHeight*1.0f;
		
		if(Platform_IsPS4())
		{
			vControllerSize *= 0.5f;
			fControllerAlpha = 0.8f;
			
			fGfxHeight = vFrameSize.y*0.12f;
			fEntrySeparation = fGfxHeight*1.0f;
		}
		
		
		
		cImGuiGfx gfxController;
		array<cVector3f> vControlGroupPositions;
		
		GetGamepadProfileLayout(asProfile, gfxController, vControlGroupPositions, vReferencePos, vFrameSize, fGfxHeight, fEntrySeparation);
		
		ImGui_SetModColorMul(cColor(1, fControllerAlpha*afAlpha));
		ImGui_SetAlignment(eImGuiAlign_CenterCenter);
		ImGui_DoImage(gfxController, vReferencePos+cVector3f(vFrameSize.x, vFrameSize.y,0)*0.5f, vControllerSize);
		ImGui_SetAlignment(eImGuiAlign_TopLeft);
		
		ImGui_SetModColorMul(cColor(1, afAlpha));
		
		vReferencePos.z += 1.0f;
		
		cImGuiLabelData labelData;
		labelData.mFont.SetFile("sansation_medium.fnt");
		labelData.mFont.mvSize = cVector2f(fGfxHeight/2.6f);
		labelData.mFont.mColor = cColor(1,1);
		labelData.mFontAlign = eFontAlign_Center;
		
		// Left shoulder buttons
		cVector3f vPos = vControlGroupPositions[0];
		
		DrawGamepadButtonActionPair(asProfile, asPreset, "Gamepad.0.Axis.4.Positive", labelData, vPos, fGfxHeight, false);
		vPos.y += fEntrySeparation;
		DrawGamepadButtonActionPair(asProfile, asPreset, "Gamepad.0.Button.9", labelData, vPos, fGfxHeight, false);
	
		// Right shoulder buttons
		vPos = vControlGroupPositions[1];
		DrawGamepadButtonActionPair(asProfile, asPreset, "Gamepad.0.Axis.5.Positive", labelData, vPos, fGfxHeight);
		vPos.y += fEntrySeparation;
		DrawGamepadButtonActionPair(asProfile, asPreset, "Gamepad.0.Button.10", labelData, vPos, fGfxHeight);
		
		vPos = vControlGroupPositions[2];
		DrawGamepadButtonActionPair(asProfile, asPreset, "Gamepad.0.Button.4", labelData, vPos, fGfxHeight, false);
		
		vPos = vControlGroupPositions[3];
		DrawGamepadButtonActionPair(asProfile, asPreset, "Gamepad.0.Button.6", labelData, vPos, fGfxHeight);
		
		vPos = vControlGroupPositions[4];
		DrawGamepadButtonActionPair(asProfile, asPreset, "Gamepad.0.Button.11", labelData, vPos, fGfxHeight, false);
		vPos.y += fEntrySeparation;
		DrawGamepadButtonActionPair(asProfile, asPreset, "Gamepad.0.Button.12", labelData, vPos, fGfxHeight, false);
		vPos.y += fEntrySeparation;
		DrawGamepadButtonActionPair(asProfile, asPreset, "Gamepad.0.Button.13", labelData, vPos, fGfxHeight, false);
		vPos.y += fEntrySeparation;
		DrawGamepadButtonActionPair(asProfile, asPreset, "Gamepad.0.Button.14", labelData, vPos, fGfxHeight, false);
		
		vPos = vControlGroupPositions[5];
		DrawGamepadButtonActionPair(asProfile, asPreset, "Gamepad.0.Axis.0.Positive.Axis.1.Negative", labelData, vPos, fGfxHeight, false);
		
		vPos = vControlGroupPositions[6];
		DrawGamepadButtonActionPair(asProfile, asPreset, "Gamepad.0.Axis.2.Positive.Axis.3.Negative", labelData, vPos, fGfxHeight);
		
		vPos = vControlGroupPositions[7];
		DrawGamepadButtonActionPair(asProfile, asPreset, "Gamepad.0.Button.0", labelData, vPos, fGfxHeight);
		vPos.y += fEntrySeparation;
		DrawGamepadButtonActionPair(asProfile, asPreset, "Gamepad.0.Button.1", labelData, vPos, fGfxHeight);
		vPos.y += fEntrySeparation;
		DrawGamepadButtonActionPair(asProfile, asPreset, "Gamepad.0.Button.3", labelData, vPos, fGfxHeight);
		
		ImGui_ResetModifiers();
	}
	
	void GetGamepadProfileLayout(const tString &in asProfile, cImGuiGfx &out aGfxController, array<cVector3f> &out avControlGroupPositions, const cVector3f &in avReferencePos, const cVector2f &in avReferenceSize, float afGfxHeight, float afEntrySeparation)
	{
		if(asProfile=="X360 Controller")
		{
			aGfxController = cImGuiGfx("controller_XBOX.tga", eImGuiGfx_Texture);
			
			avControlGroupPositions.push_back(avReferencePos+cVector3f(avReferenceSize.x*0.25f, afGfxHeight, 0));									// 0 Left shoulder
			avControlGroupPositions.push_back(avReferencePos+cVector3f(avReferenceSize.x*0.75f, afGfxHeight, 0));									// 1 Right shoulder
			avControlGroupPositions.push_back(avReferencePos+cVector3f(avReferenceSize.x*0.475f, afGfxHeight, 0));									// 2 Back
			avControlGroupPositions.push_back(avReferencePos+cVector3f(avReferenceSize.x*0.525f, afGfxHeight, 0));									// 3 Start
			avControlGroupPositions.push_back(avControlGroupPositions[0]+cVector3f(0,afEntrySeparation*4.0f,0.0f));						// 4 DPAD
			avControlGroupPositions.push_back(avControlGroupPositions[0]+cVector3f(0,afEntrySeparation*2.5f,0.0f));						// 5 Left stick
			avControlGroupPositions.push_back(avReferencePos+cVector3f(avReferenceSize.x*0.575f, avReferenceSize.y*0.9f, 0));									// 6 Right stick
			avControlGroupPositions.push_back(avControlGroupPositions[1]+cVector3f(0, afGfxHeight+afEntrySeparation*2.0f, 0));				// 7 Action button block
		}
		else if(asProfile=="PS4 Controller")
		{
			aGfxController = cImGuiGfx("controller_PS4", eImGuiGfx_Texture);
						
			avControlGroupPositions.push_back(avReferencePos+cVector3f(avReferenceSize.x*0.25f, afGfxHeight, 0));						// 0 Left shoulder
			avControlGroupPositions.push_back(avReferencePos+cVector3f(avReferenceSize.x*0.75f, afGfxHeight, 0));						// 1 Right shoulder
			avControlGroupPositions.push_back(avReferencePos+cVector3f(avReferenceSize.x*0.475f, afGfxHeight, 0));						// 2 Back
			avControlGroupPositions.push_back(avReferencePos+cVector3f(avReferenceSize.x*0.525f, afGfxHeight, 0));						// 3 Start
			avControlGroupPositions.push_back(avControlGroupPositions[0]+cVector3f(0, afEntrySeparation*3.0f,0.0f));					// 4 DPAD
			avControlGroupPositions.push_back(avReferencePos+cVector3f(avReferenceSize.x*0.425f, avReferenceSize.y*0.9f,0.0f));			// 5 Left stick
			avControlGroupPositions.push_back(avReferencePos+cVector3f(avReferenceSize.x*0.575f, avReferenceSize.y*0.9f, 0));			// 6 Right stick
			avControlGroupPositions.push_back(avControlGroupPositions[1]+cVector3f(0, afGfxHeight+afEntrySeparation*2.0f, 0));			// 7 Action button block
		}
		else
		{
			aGfxController = cImGuiGfx();
			aGfxController.mColor = cColor(0.3f, 0.3f);
			
			avControlGroupPositions.push_back(avReferencePos+cVector3f(avReferenceSize.x*0.25f, afGfxHeight, 0));						// 0 Left shoulder
			avControlGroupPositions.push_back(avReferencePos+cVector3f(avReferenceSize.x*0.75f, afGfxHeight, 0));						// 1 Right shoulder
			avControlGroupPositions.push_back(avReferencePos+cVector3f(avReferenceSize.x*0.475f, afGfxHeight, 0));						// 2 Back
			avControlGroupPositions.push_back(avReferencePos+cVector3f(avReferenceSize.x*0.525f, afGfxHeight, 0));						// 3 Start
			avControlGroupPositions.push_back(avControlGroupPositions[0]+cVector3f(0, afEntrySeparation*3.0f,0.0f));					// 4 DPAD
			avControlGroupPositions.push_back(avReferencePos+cVector3f(avReferenceSize.x*0.425f, avReferenceSize.y*0.9f,0.0f));			// 5 Left stick
			avControlGroupPositions.push_back(avReferencePos+cVector3f(avReferenceSize.x*0.575f, avReferenceSize.y*0.9f, 0));			// 6 Right stick
			avControlGroupPositions.push_back(avControlGroupPositions[1]+cVector3f(0, afGfxHeight+afEntrySeparation*2.0f, 0));			// 7 Action button block
		}
	}
	
	void DrawGamepadButtonActionPair(const tString &in asProfile, const tString &in asPreset, const tString &in asGamepadString, 
									const cImGuiLabelData &in aLabelData, const cVector3f &in avPosition, float afGfxHeight, bool abLeftToRight=true)
	{
		tString sActions;
		cLux_GetInputHandler().GetActionsAssociatedToGamepadControl(asProfile, asPreset, asGamepadString, sActions);
		
		if(sActions.length()==0) return;
						
		float fLabelSeparation = afGfxHeight*1.25f;
		
		array<tString> vActions;
		cString_GetStringVec(sActions, vActions, "/");
				
		float fLabelMaxLength = -1.0f;
		//tWString sLabel;
		array<tWString> vActionLabels;
		for(int i=0; i<vActions.size(); ++i)
		{
			tWString sActionLabel = cResources_Translate("Actions", vActions[i]);
			vActionLabels.push_back(sActionLabel);
			
			float fActionLabelLength = GetFontLengthW(aLabelData.mFont, 1.0f, sActionLabel);
			
			if(fLabelMaxLength<fActionLabelLength)
				fLabelMaxLength = fActionLabelLength;
		}
				
		tString sProfilePrefix, sInputLayoutString;
		cLux_GetInputHandler().FetchGamepadInputLayoutString(asGamepadString, sProfilePrefix, sInputLayoutString);
		array<tString> vGfxParts;
		cString_GetStringVec(sInputLayoutString, vGfxParts, ",");
		
		cVector3f vPosition = avPosition;
		vPosition.z += vGfxParts.length()*0.01f;
		
		eImGuiAlign align = eImGuiAlign_CenterRight;
		if(abLeftToRight)
		{
			align = eImGuiAlign_CenterLeft;
		}
		else
		{
			align = eImGuiAlign_CenterRight;
		}
				
		ImGui_SetAlignment(align);
		
		for(int i=0; i<vGfxParts.length(); ++i)
		{
			tString sGfxFile = sProfilePrefix + "/" + vGfxParts[i];
			cImGuiGfx gfxControl(sGfxFile, eImGuiGfx_Texture);
			cVector2f vControlSize = ImGui_GetRatioCorrectSizeByHeight(gfxControl, afGfxHeight);
			ImGui_DoImage(gfxControl, vPosition, vControlSize);
		
			vPosition.z -= 0.01f;
		}
		
		cVector2f vLayoutSize = cVector2f(0, vActionLabels.length()*aLabelData.mFont.mvSize.y+2.0f);

		cVector3f vLayoutPos = avPosition;
		vLayoutPos.y -= vLayoutSize.y*0.5f;
		if(abLeftToRight)
		{
			vLayoutPos.x += fLabelSeparation;
			align = eImGuiAlign_TopLeft;
		}
		else
		{
			align = eImGuiAlign_TopRight;
			vLayoutPos.x -= fLabelSeparation;
		}
				
		ImGui_SetAlignment(align);
							
			
		ImGui_LayoutBegin(eImGuiLayout_Y, vLayoutPos, vLayoutSize);
			for(int i=0; i<vActionLabels.length(); ++i)
				cLux_GetCurrentImGui().DoLabel(vActionLabels[i], aLabelData);
		ImGui_LayoutEnd();
		
		ImGui_SetAlignment(eImGuiAlign_TopLeft);
	}

	//-------------------------------------------------------
	
	void GuiOptionsVideo()
	{
		////////////////////////////////////
		// Options background
		ImGui_DrawFrame(mGfxFrame, OptionMenu_GetTopLeftOffset(kOptionsBgPos, 0.0), OptionMenu_GetScaledSize(kOptionsVideoBgSize));
		
		////////////////
		// Title
		OptionMenu_SectionTitle("Video", kOptionsBgPos, kOptionsVideoBgSize);
		
		int lY = 0;
		
		/////////////////
		// Autodetect settings
		
		if(Platform_IsPS4()==false)
		{
			if(OptionMenu_ButtonOptions("AutoDetect", kMainMenuButtonPos, lY, msSelectedVideoButton))
			{
				/////////////
				// Show detect settings popup
				mbShowDetectSettings = true;
				msFocusNextFrame = "NO";
				mlCurrentOptionChange = mlOptionChanges; //keep track of number of changes that have been made, determines if "Apply Changes" window should show
			}
			
			msSelectedVideoButton = OptionMenu_UpdateFocus("AutoDetect", msSelectedVideoButton);
			
			lY++;
		}
		
		/////////////////
		// Display
		{
			if(OptionMenu_ButtonOptions("Display", kMainMenuButtonPos, lY, msSelectedVideoButton))
			{
				mlCurrentResolution = GetCurrentResolution(); //keep track of resolution to be able to revert if invalid is selected
				msCurrentDisplayMode = cString_ToLowerCase(mpConfig.GetString("Screen", "FullScreen", "true"));
				
				
				mCurrentGroup = eMainMenuGroup_Options_Video_Display;
				msFocusNextFrame = msSelectedVideoDisplayButton;
				mlCurrentOptionChange = mlOptionChanges; //keep track of number of changes that have been made, determines if "Apply Changes" window should show
			}

			msSelectedVideoButton = OptionMenu_UpdateFocus("Display", msSelectedVideoButton);
		}
		
		/////////////////
		// PostEffect
		lY++;
		{
			if(OptionMenu_ButtonOptions("PostEffect", kMainMenuButtonPos, lY, msSelectedVideoButton))
			{
				mlCurrentResolution = GetCurrentResolution(); //keep track of resolution to be able to revert if invalid is selected
				mCurrentGroup = eMainMenuGroup_Options_Video_PostEffect;
				msFocusNextFrame = msSelectedVideoPostEffectButton;
				mlCurrentOptionChange = mlOptionChanges;
			}

			msSelectedVideoButton = OptionMenu_UpdateFocus("PostEffect", msSelectedVideoButton);
		}

		/////////////////
		// World
		lY++;
		{
			if(OptionMenu_ButtonOptions("Rendering", kMainMenuButtonPos, lY, msSelectedVideoButton))
			{
				mlCurrentResolution = GetCurrentResolution(); //keep track of resolution to be able to revert if invalid is selected
				mCurrentGroup = eMainMenuGroup_Options_Video_World;
				msFocusNextFrame = msSelectedVideoWorldButton;
				mlCurrentOptionChange = mlOptionChanges;
			}

			msSelectedVideoButton = OptionMenu_UpdateFocus("Rendering", msSelectedVideoButton);
		}

		/////////////////
		// Gamma
		lY++;
		{
			if(OptionMenu_ButtonOptions("Gamma", kMainMenuButtonPos, lY, msSelectedVideoButton))
			{
				mlCurrentResolution = GetCurrentResolution(); //keep track of resolution to be able to revert if invalid is selected
				mbShowingGammaMenu = true;
				/*if(mbMainMenuActive)
				{
					cLux_AddDebugMessage("GOTO MAIN!");
					mCurrentGroup = eMainMenuGroup_Main;
					msFocusNextFrame = "Gamma";
					mlCurrentOptionChange = mlOptionChanges;
				}
				else*/
				{
					mCurrentGroup = eMainMenuGroup_Options_Video_Gamma;
					msFocusNextFrame = msSelectedVideoGammaButton;
				}
			}

			msSelectedVideoButton = OptionMenu_UpdateFocus("Gamma", msSelectedVideoButton);
		}

		/////////////////
		// Back
		lY++;
		lY++;
		{
			bool bButton = OptionMenu_ButtonOptions("Back", kMainMenuButtonPos, lY, msSelectedVideoButton);
			bool bGamepad = ImGui_ActionTriggered(eImGuiAction_Cancel, true);

			if(bButton || bGamepad)
			{
				mCurrentGroup = eMainMenuGroup_Options;
				msFocusNextFrame = msSelectedOptionsButton;

				//////////
				// Reset menu poos
				if(bGamepad == false)
				{
					OptionMenu_GamepadButtons(false);
					msSelectedVideoButton = "AutoDetect";
					return;
				}
			}

			msSelectedVideoButton = OptionMenu_UpdateFocus("Back", msSelectedVideoButton);
		}

		///////////
		// Show gamepad legacy
		OptionMenu_GamepadButtons(false);
	}

	void GuiOptionsVideoDisplay()
	{
		array<tString> vDisplayValues = { "Fullscreen", "Windowed", "Borderless" };
		array<tString> vVSyncValues = { "On", "Adaptive", "Off" };
		array<tString> vAAValues = { "Off", "FXAA" };
	
		OptionMenu_UpdateExtraWidth("Resolution", false);
		OptionMenu_UpdateExtraWidth("DisplayMode", false);
		OptionMenu_UpdateExtraWidth("VSync", false);
		OptionMenu_UpdateExtraWidth("RefreshRate", false);
		OptionMenu_UpdateExtraWidth("AA", false);
		OptionMenu_UpdateExtraWidth("FOV", false);
		OptionMenu_UpdateExtraButtonWidth_MultiSelection(vDisplayValues);
		OptionMenu_UpdateExtraButtonWidth_MultiSelection(vVSyncValues);
		OptionMenu_UpdateExtraButtonWidth_MultiSelection(vAAValues);
		
		
		////////////////////////////////////
		// Options background
		ImGui_DrawFrame(mGfxFrame, OptionMenu_GetTopLeftOffset(kOptionsBgPos, 0.0), OptionMenu_GetScaledSize(kOptionsVideoDisplayBgSize+cVector2f(OptionMenu_GetExtraWidth(), 0)));
		
		////////////////
		// Title
		OptionMenu_SectionTitle("Display", kOptionsBgPos, kOptionsVideoDisplayBgSize);
		
		int lY = 0;

		/////////////////
		// Resolution
		{
			/////////////
			// Get current resolution and update config
			int lResolution = GetCurrentResolution();
			int lNewResolution = OptionMenu_ButtonOptionsMultiSelect("Resolution", kMainMenuButtonPos, lY, msSelectedVideoDisplayButton, mvResolutionValues, lResolution, false, mlActionHorizontal, "");
			
			if(lResolution != lNewResolution)
			{
				mlOptionChanges++;
				SetCurrentResolution(lNewResolution);
			}

			msSelectedVideoDisplayButton = OptionMenu_UpdateFocus("Resolution", msSelectedVideoDisplayButton);
		}
		
		/////////////////
		// Display Mode
		lY++;
		{
			//////////////
			// Draw button and update config

			tString sValue = cString_ToLowerCase(mpConfig.GetString("Screen", "FullScreen", "true"));

			int lValue = (sValue == "true") ? 0 : (sValue == "borderless" ? 2 : 1); 
			int lNewValue = OptionMenu_ButtonOptionsMultiSelect("DisplayMode", kMainMenuButtonPos, lY, msSelectedVideoDisplayButton, vDisplayValues, lValue, false, mlActionHorizontal);

			if(lValue != lNewValue)
			{
				mlOptionChanges++;
				mpConfig.SetString("Screen", "FullScreen", (lNewValue == 0) ? "true" :
														   (lNewValue == 1	? "false" : "borderless"));
			}

			msSelectedVideoDisplayButton = OptionMenu_UpdateFocus("DisplayMode", msSelectedVideoDisplayButton);
		}
		
		/////////////////
		// V-sync
		lY++;
		{
			//////////////
			// Draw button and update config
			tString sValue = cString_ToLowerCase(mpConfig.GetString("Screen", "Vsync", "true"));

			int lValue = (sValue == "true") ? 0 : (sValue == "adaptive" ? 1 : 2);
			int lNewValue = OptionMenu_ButtonOptionsMultiSelect("VSync", kMainMenuButtonPos, lY, msSelectedVideoDisplayButton, vVSyncValues, lValue, false, mlActionHorizontal);
			
			if(lValue != lNewValue)
			{
				mlOptionChanges++;
				mpConfig.SetString("Screen", "Vsync",	(lNewValue == 0)	? "true" :
														(lNewValue == 1		? "adaptive" : "false"));
			}
			 
			msSelectedVideoDisplayButton = OptionMenu_UpdateFocus("VSync", msSelectedVideoDisplayButton);
		}

		/////////////////
		// Refresh rate
		lY++;
		{
			//////////////
			// Draw button and update config
			array<tString> vValues = { "On", "Adaptive", "Off" };
			tString sValue = cString_ToLowerCase(mpConfig.GetString("Screen", "Vsync", "true"));

			int lValue = GetCurrentRefreshRate();
			int lNewValue = OptionMenu_ButtonOptionsMultiSelect("RefreshRate", kMainMenuButtonPos, lY, msSelectedVideoDisplayButton, mvRefreshValues, lValue, false, mlActionHorizontal, "");
			
			if(lValue != lNewValue)
			{
				mlOptionChanges++;
				SetCurrentRefreshRate(lNewValue);
			}
			 
			msSelectedVideoDisplayButton = OptionMenu_UpdateFocus("RefreshRate", msSelectedVideoDisplayButton);
		}
		
		/////////////////
		// AA
		lY++;
		{
			/////////////
			// Draw multi select box and update config
			tString sValue = mpConfig.GetString("Graphics", "AntiAliasing", "FXAA");

			int lValue = (sValue == "FXAA") ? 1 : 0;
			int lNewValue = OptionMenu_ButtonOptionsMultiSelect("AA", kMainMenuButtonPos, lY, msSelectedVideoDisplayButton, vAAValues, lValue, true, mlActionHorizontal);
			
			if(lValue != lNewValue)
			{
				mlOptionChanges++;
				mpConfig.SetString("Graphics", "AntiAliasing", vAAValues[lNewValue]);
			}

			msSelectedVideoDisplayButton = OptionMenu_UpdateFocus("AA", msSelectedVideoDisplayButton);
		}

		/////////////////
		// FOV
		lY++;
		{
			float fFOVMin = 50;
			float fFOVMax = 83;
			float fValue = mpConfig.GetFloat("Gameplay", "FOV", 70);

			float fAspectRatio = mpConfig.GetFloat("Screen", "Width", 1920) / mpConfig.GetFloat("Screen", "Height", 1080);
			float fHorizontalFov = 2.0f * cMath_ATan(cMath_Tan(cMath_ToRad(fValue) / 2.0f) * fAspectRatio);
			tString sTextValue = "" + cMath_RoundToInt(cMath_ToDeg(fHorizontalFov));

			fValue = (fValue - fFOVMin) / (fFOVMax - fFOVMin);
			float fNewValue = OptionMenu_ButtonOptionsSlider("FOV", kMainMenuButtonPos, lY, msSelectedVideoDisplayButton, fValue, 0.2f / 4.0f, mlActionHorizontal, sTextValue);
			
			if(fValue != fNewValue)
			{
				mlOptionChanges++;
				fNewValue = fNewValue * (fFOVMax - fFOVMin) + fFOVMin;
				mpConfig.SetFloat("Gameplay", "FOV", fNewValue);
			}

			msSelectedVideoDisplayButton = OptionMenu_UpdateFocus("FOV", msSelectedVideoDisplayButton);
		}

		/////////////////
		// Back
		lY++;
		lY++;
		{
			bool bButton = OptionMenu_ButtonOptions("Back", kMainMenuButtonPos, lY, msSelectedVideoDisplayButton);
			bool bGamepad = ImGui_ActionTriggered(eImGuiAction_Cancel, true);

			if(bButton || bGamepad)
			{
				if(mlCurrentOptionChange != mlOptionChanges)
				{
					// Changes has been made
					mbShowApplyChanges = true;
					msFocusNextFrame = "NO";
				}
				else
				{
					// No changes
					mCurrentGroup = eMainMenuGroup_Options_Video;

					msFocusNextFrame = msSelectedVideoButton;
				}

				//////////
				// Reset menu poos
				if(bGamepad == false)
				{
					OptionMenu_GamepadButtons(msSelectedVideoDisplayButton != "Back");
					msSelectedVideoDisplayButton = "Resolution";
					return;
				}
			}

			msSelectedVideoDisplayButton = OptionMenu_UpdateFocus("Back", msSelectedVideoDisplayButton);
		}

		///////////
		// Show gamepad legacy
		OptionMenu_GamepadButtons(msSelectedVideoDisplayButton != "Back");
	}
	
	void GuiOptionsVideoWorld()
	{
		array<tString> vTextureValues = { "High", "Medium", "Low" };
		array<tString> vTextureFilterValues = { "Bilinear", "Trilinear", "Anis2x", "Anis4x", "Anis8x", "Anis16x" };
		array<tString> vShadowValues = { "Off", "Low", "Medium", "High", "VeryHigh" };
		OptionMenu_UpdateExtraWidth("TextureQuality", false);
		OptionMenu_UpdateExtraWidth("TextureFiltering", false);
		OptionMenu_UpdateExtraWidth("ShadowQuality", false);
		OptionMenu_UpdateExtraWidth("Reflection", true);
		OptionMenu_UpdateExtraWidth("Refraction", true);
		OptionMenu_UpdateExtraButtonWidth_Toggle();
		OptionMenu_UpdateExtraButtonWidth_MultiSelection(vTextureValues);
		OptionMenu_UpdateExtraButtonWidth_MultiSelection(vTextureFilterValues);
		OptionMenu_UpdateExtraButtonWidth_MultiSelection(vShadowValues);
		
		////////////////////////////////////
		// Options background
		ImGui_DrawFrame(mGfxFrame, OptionMenu_GetTopLeftOffset(kOptionsBgPos, 0.0), OptionMenu_GetScaledSize(kOptionsVideoWorldBgSize+cVector2f(OptionMenu_GetExtraWidth(), 0)));
		
		////////////////
		// Title
		OptionMenu_SectionTitle("Rendering", kOptionsBgPos, kOptionsVideoWorldBgSize);
		
		int lY = 0;
		
		/////////////////
		// Textures
		{
			/////////////
			// Draw multi select box and update config
			int lValue = mpConfig.GetInt("Graphics", "TextureQuality", 0);
			int lNewValue = OptionMenu_ButtonOptionsMultiSelect("TextureQuality", kMainMenuButtonPos, lY, msSelectedVideoWorldButton, vTextureValues, lValue, true, mlActionHorizontal);
			
			if(lValue != lNewValue)
			{
				mpConfig.SetInt("Graphics", "TextureQuality", lNewValue);
				mlOptionChanges++;
			}

			msSelectedVideoWorldButton = OptionMenu_UpdateFocus("TextureQuality", msSelectedVideoWorldButton);
		}

		/////////////////
		// Textures Filtering
		lY++;
		{
			/////////////
			// Draw multi select box and update config
			int lFilter = mpConfig.GetInt("Graphics", "TextureFilter", 0);
			int lAnis = mpConfig.GetInt("Graphics", "TextureAnisotropy", 0);

			int lValue = 0;

			if(lAnis < 2)
			{
				lValue = lFilter == 2 ? 1 : 0;
			}
			else
			{
				if(lAnis == 2)		lValue = 2;
				else if(lAnis == 4) lValue = 3;
				else if(lAnis == 8) lValue = 4;
				else				lValue = 5;
			}

			int lNewValue = OptionMenu_ButtonOptionsMultiSelect("TextureFiltering", kMainMenuButtonPos, lY, msSelectedVideoWorldButton, vTextureFilterValues, lValue, false, mlActionHorizontal);
			
			if(lValue != lNewValue)
			{
				switch(lNewValue)
				{
				case 0:
					lAnis = 1;
					lFilter = 1;
					break;
				case 1:
					lAnis = 1;
					lFilter = 2;
					break;
				case 2:
					lAnis = 2;
					lFilter = 2;
					break;
				case 3:
					lAnis = 4;
					lFilter = 2;
					break;
				case 4:
					lAnis = 8;
					lFilter = 2;
					break;
				case 5:
					lAnis = 16;
					lFilter = 2;
					break;
				}

				
				mpConfig.SetInt("Graphics", "TextureFilter", lFilter);
				mpConfig.SetInt("Graphics", "TextureAnisotropy", lAnis);
				mlOptionChanges++;
			}

			msSelectedVideoWorldButton = OptionMenu_UpdateFocus("TextureFiltering", msSelectedVideoWorldButton);
		}

		/////////////////
		// Shadows
		lY++;
		{
			/////////////
			// Draw multi select and update config
			int lShadowActive = mpConfig.GetBool("Graphics", "ShadowsActive", true) ? 1 : 0;
			int lShadowQuality = mpConfig.GetInt("Graphics", "ShadowResolution", 2);
			int lValue = lShadowActive * (lShadowQuality+1);
			int lNewValue = OptionMenu_ButtonOptionsMultiSelect("ShadowQuality", kMainMenuButtonPos, lY, msSelectedVideoWorldButton, vShadowValues, lValue, false, mlActionHorizontal);
				
			if(lValue != lNewValue)
			{	
				if(lNewValue == 0)
				{
					mpConfig.SetBool("Graphics", "ShadowsActive", false);
				}
				else
				{
					mpConfig.SetBool("Graphics", "ShadowsActive", true);
					mpConfig.SetInt("Graphics", "ShadowResolution", lNewValue-1);
				}
				mlOptionChanges++;
			}

			msSelectedVideoWorldButton = OptionMenu_UpdateFocus("ShadowQuality", msSelectedVideoWorldButton);
		}
		
		/////////////////
		// Reflection
		lY++;
		{
			//////////////
			// Draw button and update config
			bool bValue = mpConfig.GetBool("Graphics", "WorldReflection", true);
			bool bNewValue = OptionMenu_ButtonOptionsToggle("Reflection", kMainMenuButtonPos, lY, msSelectedVideoWorldButton, bValue, mlActionHorizontal);
			
			if(bValue != bNewValue)
			{
				mpConfig.SetBool("Graphics", "WorldReflection", bNewValue);
				mlOptionChanges++;
			}
			
			msSelectedVideoWorldButton = OptionMenu_UpdateFocus("Reflection", msSelectedVideoWorldButton);
		}

		/////////////////
		// Refraction
		lY++;
		{
			//////////////
			// Draw button and update config
			bool bValue = mpConfig.GetBool("Graphics", "Refraction", true);
			bool bNewValue = OptionMenu_ButtonOptionsToggle("Refraction", kMainMenuButtonPos, lY, msSelectedVideoWorldButton, bValue, mlActionHorizontal);
			
			if(bValue != bNewValue)
			{
				mpConfig.SetBool("Graphics", "Refraction", bNewValue);
				mlOptionChanges++;
			}
			
			msSelectedVideoWorldButton = OptionMenu_UpdateFocus("Refraction", msSelectedVideoWorldButton);
		}
		/*
		/////////////////
		// Tesselation
		lY++;
		{
			/////////////
			// Draw multi select and update config
			array<tString> vValues = { "Off", "Low", "Medium", "High" };
			int lValue = mpConfig.GetInt("Graphics", "TerrainTessellation", 0);
			int lNewValue = OptionMenu_ButtonOptionsMultiSelect("TerrainTessellation", kMainMenuButtonPos, lY, msSelectedVideoWorldButton, vValues, lValue, false, mlActionHorizontal);
					
			if(lValue != lNewValue)
			{	
				mpConfig.SetInt("Graphics", "TerrainTessellation", lNewValue);
				mlOptionChanges++;
			}

			msSelectedVideoWorldButton = OptionMenu_UpdateFocus("TerrainTessellation", msSelectedVideoWorldButton);
		}
		*/
		/////////////////
		// Back
		lY++;
		lY++;
		{
			bool bButton = OptionMenu_ButtonOptions("Back", kMainMenuButtonPos, lY, msSelectedVideoWorldButton);
			bool bGamepad = ImGui_ActionTriggered(eImGuiAction_Cancel, true);

			if(bButton || bGamepad)
			{
				if(mlCurrentOptionChange != mlOptionChanges)
				{
					// Changes has been made
					mbShowApplyChanges = true;
					msFocusNextFrame = "NO";
				}
				else
				{
					// No changes
					mCurrentGroup = eMainMenuGroup_Options_Video;
					msFocusNextFrame = msSelectedVideoButton;
				}

				//////////
				// Reset menu poos
				if(bGamepad == false)
				{
					OptionMenu_GamepadButtons(msSelectedVideoWorldButton != "Back");
					msSelectedVideoWorldButton = "TextureQuality";
					return;
				}
			}

			msSelectedVideoWorldButton = OptionMenu_UpdateFocus("Back", msSelectedVideoWorldButton);
		}

		///////////
		// Show gamepad legacy
		OptionMenu_GamepadButtons(msSelectedVideoWorldButton != "Back");
	}

	
	void GuiOptionsVideoPostEffect()
	{
		array<tString> vDOFValues = {"Low", "Medium", "High"};
		OptionMenu_UpdateExtraWidth("DepthOfField", false);
		OptionMenu_UpdateExtraWidth("SSAO", true);
		OptionMenu_UpdateExtraWidth("Bloom", true);
		OptionMenu_UpdateExtraButtonWidth_Toggle();
		OptionMenu_UpdateExtraButtonWidth_MultiSelection(vDOFValues);
		
		////////////////////////////////////
		// Options background
		ImGui_DrawFrame(mGfxFrame, OptionMenu_GetTopLeftOffset(kOptionsBgPos, 0.0), OptionMenu_GetScaledSize(kOptionsVideoPostEffectBgSize+cVector2f(OptionMenu_GetExtraWidth(), 0)));
		
		////////////////
		// Title
		OptionMenu_SectionTitle("PostEffect", kOptionsBgPos, kOptionsVideoPostEffectBgSize);
		
		int lY = 0;
		
		/////////////////
		// DOF
		{
			/////////////
			// Draw multi select box and update config
			int lValue = mpConfig.GetInt("Graphics", "DepthOfFieldQuality", 2);
			int lNewValue = OptionMenu_ButtonOptionsMultiSelect("DepthOfField", kMainMenuButtonPos, lY, msSelectedVideoPostEffectButton, vDOFValues, lValue, false, mlActionHorizontal);
			
			if(lValue != lNewValue)
			{
				mpConfig.SetInt("Graphics", "DepthOfFieldQuality", lNewValue);
				mlOptionChanges++;
			}

			msSelectedVideoPostEffectButton = OptionMenu_UpdateFocus("DepthOfField", msSelectedVideoPostEffectButton);
		}


		/////////////////
		// SSAO
		lY++;
		{
			//////////////
			// Draw button and update config
			bool bValue = mpConfig.GetBool("Graphics", "SSAOActive", true);
			bool bNewValue = OptionMenu_ButtonOptionsToggle("SSAO", kMainMenuButtonPos, lY, msSelectedVideoPostEffectButton, bValue, mlActionHorizontal);
			
			if(bValue != bNewValue)
			{
				mpConfig.SetBool("Graphics", "SSAOActive", bNewValue);
				mlOptionChanges++;
			}
			
			msSelectedVideoPostEffectButton = OptionMenu_UpdateFocus("SSAO", msSelectedVideoPostEffectButton);
		}

		/////////////////
		// Bloom
		lY++;
		{
			//////////////
			// Draw button and update config
			bool bValue = mpConfig.GetBool("Graphics", "BloomActive", true);
			bool bNewValue = OptionMenu_ButtonOptionsToggle("Bloom", kMainMenuButtonPos, lY, msSelectedVideoPostEffectButton, bValue, mlActionHorizontal);
			
			if(bValue != bNewValue)
			{
				mpConfig.SetBool("Graphics", "BloomActive", bNewValue);
				mlOptionChanges++;
			}
			
			msSelectedVideoPostEffectButton = OptionMenu_UpdateFocus("Bloom", msSelectedVideoPostEffectButton);
		}

		/////////////////
		// Back
		lY++;
		lY++;
		{
			bool bButton = OptionMenu_ButtonOptions("Back", kMainMenuButtonPos, lY, msSelectedVideoPostEffectButton);
			bool bGamepad = ImGui_ActionTriggered(eImGuiAction_Cancel, true);

			if(bButton || bGamepad)
			{
				if(mlCurrentOptionChange != mlOptionChanges)
				{
					// Changes has been made
					mbShowApplyChanges = true;
					msFocusNextFrame = "NO";
				}
				else
				{
					// No changes
					mCurrentGroup = eMainMenuGroup_Options_Video;
					msFocusNextFrame = msSelectedVideoButton;
				}

				//////////
				// Reset menu poos
				if(bGamepad == false)
				{
					OptionMenu_GamepadButtons(msSelectedVideoPostEffectButton != "Back");
					msSelectedVideoPostEffectButton = "DepthOfField";
					return;
				}
			}

			msSelectedVideoPostEffectButton = OptionMenu_UpdateFocus("Back", msSelectedVideoPostEffectButton);
		}

		///////////
		// Show gamepad legacy
		OptionMenu_GamepadButtons(msSelectedVideoPostEffectButton != "Back");
	}

	void GuiOptionsVideoGamma()
	{
		////////////////////////////////////
		// Options background
		ImGui_DrawFrame(mGfxFrame, OptionMenu_GetTopLeftOffset(kOptionsBgPos, 0.0), OptionMenu_GetScaledSize(kOptionsVideoGammaBgSize));
		
		////////////////
		// Title
		OptionMenu_SectionTitle("Gamma", kOptionsBgPos, kOptionsVideoGammaBgSize);
		
		int lY = 0;
		
		/////////////////
		// Gamma
		{
			float fValue = (mpConfig.GetFloat("Graphics", "Brightness", 1.0f) - 0.3f) / (2.0f - 0.6f);
			float fNewValue = OptionMenu_ButtonOptionsSlider("Gamma", kMainMenuButtonPos, lY, msSelectedVideoGammaButton, fValue, 0.05f, mlActionHorizontal, "");

			if(fNewValue != fValue)
			{
				mpConfig.SetFloat("Graphics", "Brightness", (fNewValue * (2.0f - 0.6f) + 0.3f));
				ApplySettings(false);
			}

			msSelectedVideoGammaButton = OptionMenu_UpdateFocus("Gamma", msSelectedVideoGammaButton);
		}


		/////////////////
		// Back
		lY++;
		lY++;
		{
			bool bButton = OptionMenu_ButtonOptions("Back", kMainMenuButtonPos, lY, msSelectedVideoGammaButton);
			bool bGamepad = ImGui_ActionTriggered(eImGuiAction_Cancel, true);

			if(bButton || bGamepad)
			{
				if(Platform_IsPS4())
				{
					mCurrentGroup = eMainMenuGroup_Options;
					msFocusNextFrame = msSelectedOptionsButton;
				}
				else
				{
					mCurrentGroup = eMainMenuGroup_Options_Video;
					msFocusNextFrame = msSelectedVideoButton;
				}

				ApplySettings();

				//////////
				// Reset menu poos
				if(bGamepad == false)
				{
					if(Platform_IsPS4())
					{
						msSelectedOptionsButton = "Gamma";
					}
					else
					{
						msSelectedVideoGammaButton = "Gamma";
					}

					OptionMenu_GamepadButtons(msSelectedVideoGammaButton != "Back");
					return;
				}
			}

			msSelectedVideoGammaButton = OptionMenu_UpdateFocus("Back", msSelectedVideoGammaButton);
		}

		///////////
		// Show gamepad legacy
		OptionMenu_GamepadButtons(msSelectedVideoGammaButton != "Back");
	}

	int GetCurrentResolution()
	{
		cVector2l vResolution = cVector2l(mpConfig.GetInt("Screen", "Width", 1280), 
									      mpConfig.GetInt("Screen", "Height", 720));

		if(vResolution.x == -1 || vResolution.y == -1)
		{
			vResolution.x = cGraphics_GetLowLevel().GetScreenSizeInt().x;
			vResolution.y = cGraphics_GetLowLevel().GetScreenSizeInt().y;
		}

		for(int i = 0; i < mvResolutionSizes.size(); ++i)
		{
			if(vResolution == mvResolutionSizes[i])
			{
				return i;
			}
		} 

		////////////
		// Custom resolution
		mvResolutionSizes.push_back(vResolution);
		mvResolutionValues.push_back(""+vResolution.x + "x"+vResolution.y);

		return mvResolutionValues.size()-1;
	}

	void SetCurrentResolution(int aID)
	{
		aID = (aID + mvResolutionSizes.size()) % mvResolutionSizes.size();

		mpConfig.SetInt("Screen", "Width", mvResolutionSizes[aID].x);
		mpConfig.SetInt("Screen", "Height", mvResolutionSizes[aID].y);
	}

	int GetCurrentRefreshRate()
	{
		int lRate = mpConfig.GetInt("Screen", "RefreshRate", 0);

		if(lRate == 0)
		{
			lRate = mvRefresh[mvRefresh.size()-1];
		}

		for(int i = 0; i < mvRefresh.size(); ++i)
		{
			if(lRate == mvRefresh[i])
			{
				return i;
			}
		} 

		////////////
		// Custom resolution
		mvRefresh.push_back(lRate);
		mvRefreshValues.push_back(""+lRate);

		return mvRefreshValues.size()-1;
	}

	void SetCurrentRefreshRate(int aID)
	{
		aID = (aID + mvRefresh.size()) % mvRefresh.size();

		mpConfig.SetInt("Screen", "RefreshRate", mvRefresh[aID]);
	}
	
	//------------------------------------------------------
	
	int GetBaseQualityAMD(tString asPrefix, int alCardNumber)
	{
		if(asPrefix == "HD")
		{
			if(alCardNumber < 5000) return 0;
			if(alCardNumber < 6600) return 1;
			if(alCardNumber < 7600) return 2;
			if(alCardNumber < 8600) return 3;
			if(alCardNumber < 9600) return 3;
		}
		else if(asPrefix == "R5")
		{
			return 1;
		}
		else if(asPrefix == "R7")
		{
			return 3;
		}
		else if(asPrefix == "R9")
		{
			return 4;
		}

		return -1;
	} 

	int GetBaseQualityNvidia(int alCardNumber)
	{
		if(alCardNumber < 100 || alCardNumber > 1000) return -1;

		if(alCardNumber < 450) return 0;
		if(alCardNumber < 550) return 1;
		if(alCardNumber < 650) return 2;
		if(alCardNumber < 750) return 3;
		if(alCardNumber < 850) return 3;
		if(alCardNumber < 1000) return 4;

		return -1;
	}

	void GetQualityAndMemoryFromRenderer(int&out alQuality, int&out alVRAM)
	{
		/////////////
		// Get and parse graphics info
		tString sGraphicsInfo = cGraphics_GetLowLevel().GetGraphicsInfo();
		Log("GraphicsInfo: " + sGraphicsInfo + "\n");
		array<tString> vInfo;
		cString_GetStringVec(sGraphicsInfo, vInfo, ";");

		alQuality = -1;
		alVRAM = -1;

		if(vInfo.size() >= 5)
		{
			/////////////////
			// Parse vram
			array<tString> vVRAM;
			cString_GetStringVec(vInfo[4], vVRAM, " ");
			
			if(vVRAM.size() == 3)
			{
				alVRAM = cString_ToInt(vVRAM[1], -1);
			}
			else
			{
				// VRAM Parse failed, no need to continue
				return;
			}
					
			///////////////////
			// Get info about card
			array<tString> vCardName;
			cString_GetStringVec(vInfo[1], vCardName, " ,/\\");
			tString sModelPrefix;
			int lVersion = 0;
			bool bLaptop = false;

			for(uint i = 0; i < vCardName.size(); ++i)
			{
				//////////////
				// Check for mobile GPU
				int lPos = cString_GetFirstCharPos(vCardName[i], 'M');

				if(lPos == -1)
				{
					//////////////
					// Normal gpu
					lVersion = cString_ToInt(vCardName[i], 0);
				}
				else
				{
					//////////////
					// Check if its at the start or end
					if(lPos == 0)
					{
						lVersion = cString_ToInt(cString_Sub(vCardName[i], 1), 0);
						
						if(lVersion != 0) bLaptop = true;
					}
					else if(lPos == vCardName[i].length() - 1)
					{
						lVersion = cString_ToInt(cString_Sub(vCardName[i], 0, lPos), 0);

						if(lVersion != 0) bLaptop = true;
					}
				}

				if(lVersion != 0) break;

				sModelPrefix = vCardName[i];
			}

			//////////////
			// Convert card to quality setting
			if(cString_GetFirstStringPos(vInfo[0], "NVIDIA") != -1)
			{
				alQuality = GetBaseQualityNvidia(lVersion);
			}
			else if(cString_GetFirstStringPos(vInfo[0], "AMD") != -1 || 
					cString_GetFirstStringPos(vInfo[0], "ATI") != -1)
			{
				alQuality = GetBaseQualityAMD(sModelPrefix, lVersion);
			}
			else if(cString_GetFirstStringPos(vInfo[0], "Intel") != -1)
			{
				// Special case for intel cards
				alQuality = 0;
				alVRAM = 1024;
			}

			//////////////
			// Downgrade quality one level for laptops
			if(bLaptop)
			{
				alQuality = cMath_Max(alQuality - 1, 0);
			}
		}
	}
		
	void AutoDetectSettings(bool abSkipOnHigh)
	{
		if(Platform_IsPS4()) return;

		/////////////////////
		// Parse string to get quality and vram;
		int lBaseQuality;
		int lVRAM;
		GetQualityAndMemoryFromRenderer(lBaseQuality, lVRAM);
		
		/////////////////
		// Get qúality based on vram and GPU card
		eGraphicSettings setting = eGraphicSettings_High;

		if(lVRAM > 0) //valid VRAM?
		{
			switch(lBaseQuality)
			{
			case 0:
				if(lVRAM < 1024)		setting = eGraphicSettings_Low;
				else if(lVRAM < 2048)	setting = eGraphicSettings_Low;
				else					setting = eGraphicSettings_Medium;
				break;
			case 1:
				if(lVRAM <= 1024)		setting = eGraphicSettings_Low;
				else if(lVRAM < 2048)	setting = eGraphicSettings_Medium;
				else					setting = eGraphicSettings_Medium;
				break;
			case 2:
				if(lVRAM <= 512)		setting = eGraphicSettings_Low;
				else if(lVRAM < 1024)	setting = eGraphicSettings_Medium;
				else if(lVRAM < 2048)	setting = eGraphicSettings_Medium;
				else					setting = eGraphicSettings_High;
				break;
			case 3:
				if(lVRAM < 512)			setting = eGraphicSettings_Low;
				else if(lVRAM < 1024)	setting = eGraphicSettings_Medium;
				else if(lVRAM < 2048)	setting = eGraphicSettings_High;
				else					setting = eGraphicSettings_High;
				break;
			case 4:
				if(lVRAM < 512)			setting = eGraphicSettings_Low;
				else if(lVRAM < 1024)	setting = eGraphicSettings_Medium;
				else if(lVRAM < 2048)	setting = eGraphicSettings_High;
				else					setting = eGraphicSettings_High;
				break;
			default:
				setting = eGraphicSettings_High; //Set to high if unsure
				break;
			}
		}

		tString sQuality;
		if(setting == eGraphicSettings_Low)		sQuality = "Low";
		if(setting == eGraphicSettings_Medium)	sQuality = "Medium";
		if(setting == eGraphicSettings_High)	sQuality = "High";
		
		Log("AutoDetect Quality: " +  sQuality + "; Base "+ lBaseQuality + "; VRAM " + lVRAM + " mb\n");

		////////////////////
		// Update config based on quality selected
		switch(setting)
		{
		case eGraphicSettings_High:
			if(abSkipOnHigh) return;

			mpConfig.SetString("Graphics", "AntiAliasing", "FXAA");
			mpConfig.SetInt("Graphics", "TextureFilter", 2);
			mpConfig.SetInt("Graphics", "TextureAnisotropy", 16);
			mpConfig.SetBool("Graphics", "ShadowsActive", true);
			mpConfig.SetInt("Graphics", "ShadowResolution", 2);
			mpConfig.SetBool("Graphics", "WorldReflection", true);
			mpConfig.SetBool("Graphics", "Refraction", true);
			mpConfig.SetInt("Graphics", "DepthOfFieldQuality", 2);
			mpConfig.SetBool("Graphics", "SSAOActive", true);
			mpConfig.SetBool("Graphics", "BloomActive", true);
			if(mpConfig.GetInt("Screen", "RefreshRate", 0) == 30) mpConfig.SetInt("Screen", "RefreshRate", 60);
			if(lBaseQuality >= 4) mpConfig.SetString("Screen", "Vsync", "true");
			else				  mpConfig.SetString("Screen", "Vsync", "off");
			break;
		case eGraphicSettings_Medium:
			mpConfig.SetString("Graphics", "AntiAliasing", "Off");
			mpConfig.SetInt("Graphics", "TextureFilter", 2);
			mpConfig.SetInt("Graphics", "TextureAnisotropy", 2);
			mpConfig.SetBool("Graphics", "ShadowsActive", true);
			mpConfig.SetInt("Graphics", "ShadowResolution", 1);
			mpConfig.SetBool("Graphics", "WorldReflection", false);
			mpConfig.SetBool("Graphics", "Refraction", true);
			mpConfig.SetInt("Graphics", "DepthOfFieldQuality", 1);
			mpConfig.SetBool("Graphics", "SSAOActive", true);
			mpConfig.SetBool("Graphics", "BloomActive", true);
			if(mpConfig.GetInt("Screen", "RefreshRate", 0) == 30) mpConfig.SetInt("Screen", "RefreshRate", 60);
			mpConfig.SetString("Screen", "Vsync", "false");
			break;
		case eGraphicSettings_Low:
			mpConfig.SetString("Graphics", "AntiAliasing", "Off");
			mpConfig.SetInt("Graphics", "TextureFilter", 2);
			mpConfig.SetInt("Graphics", "TextureAnisotropy", 0);
			mpConfig.SetBool("Graphics", "ShadowsActive", false);
			mpConfig.SetInt("Graphics", "ShadowResolution", 0);
			mpConfig.SetBool("Graphics", "WorldReflection", false);
			mpConfig.SetBool("Graphics", "Refraction", false);
			mpConfig.SetInt("Graphics", "DepthOfFieldQuality", 0);
			mpConfig.SetBool("Graphics", "SSAOActive", false);
			mpConfig.SetBool("Graphics", "BloomActive", false);
			mpConfig.SetInt("Screen", "RefreshRate", 30);
			mpConfig.SetString("Screen", "Vsync", "false");
			break;
		}


		//////////////////
		// Update texture quality based on just the VRAM
		if(lVRAM > 0) //valid VRAM?
		{
			if(lVRAM >= 1700)		mpConfig.SetInt("Graphics", "TextureQuality", 0); //high
			else if(lVRAM >= 512)	mpConfig.SetInt("Graphics", "TextureQuality", 1); //medium
			else					mpConfig.SetInt("Graphics", "TextureQuality", 2); //low
		}

		///////////////
		// Apply config
		ApplySettings(true);
		mlCurrentResolution = GetCurrentResolution(); //keep track of resolution to be able to revert if invalid is selected
	}

	//------------------------------------------------------

	void GuiOptionsAudio()
	{
		
		////////////////////////////////////
		// Options background
		cVector2f vBgSize = kOptionsAudioBgSize;
		array<tString> vSpeakerValues = {"SmallTV", "MediumTV", "HomeCinema", "Headphones", "RemotePlay", "NightMode"};
		if(Platform_IsPS4())
		{
			vBgSize.y += 35;
			OptionMenu_UpdateExtraButtonWidth_MultiSelection(vSpeakerValues);
			OptionMenu_UpdateExtraWidth("SpeakerType", false);
		}
		OptionMenu_UpdateExtraWidth("Volume", false);
		OptionMenu_UpdateExtraWidth("Subtitles", true);
		OptionMenu_UpdateExtraWidth("HearingAid", true);
		OptionMenu_UpdateExtraButtonWidth_Toggle();
		
		ImGui_DrawFrame(mGfxFrame, OptionMenu_GetTopLeftOffset(kOptionsBgPos, 0.0), OptionMenu_GetScaledSize(vBgSize+cVector2f(OptionMenu_GetExtraWidth(), 0)));
		
		////////////////
		// Audio
		OptionMenu_SectionTitle("Audio", kOptionsBgPos, vBgSize);
		
		int lY=0;

		/////////////////
		// Speaker type
		if(Platform_IsPS4())
		{
			/////////////
			// Draw multi select box and update config
			tString sValue = mpConfig.GetString("Sound", "SpeakerType", "HomeCinema");
			int lValue =-1;
			for(int i=0;i<vSpeakerValues.size(); ++i)
			{
				if(sValue == vSpeakerValues[i]){
					lValue = i;
					break;
				}
			}
			
			int lNewValue = OptionMenu_ButtonOptionsMultiSelect("SpeakerType", kMainMenuButtonPos, lY, msSelectedAudioButton, vSpeakerValues, lValue, false, mlActionHorizontal);
			
			if(lValue != lNewValue)
			{
				mpConfig.SetString("Sound", "SpeakerType", vSpeakerValues[lNewValue]);
				ApplySettings(false);
			}

			msSelectedAudioButton = OptionMenu_UpdateFocus("SpeakerType", msSelectedAudioButton);
			lY++;
		}

		/////////////////
		// Volume
		{
			float fValue = mpConfig.GetFloat("Sound", "Volume", 1.0f);
			float fNewValue = OptionMenu_ButtonOptionsSlider("Volume", kMainMenuButtonPos, lY, msSelectedAudioButton, fValue, 0.1f, mlActionHorizontal, "");

			if(fNewValue != fValue)
			{
				mpConfig.SetFloat("Sound", "Volume", fNewValue);
				ApplySettings(false);
			}

			msSelectedAudioButton = OptionMenu_UpdateFocus("Volume", msSelectedAudioButton);
			lY++;
		}
		
		/////////////////
		// SUBTITLES
		{
			//////////////
			// Draw button and update config
			bool bValue = mpConfig.GetBool("Sound", "ShowSubtitles", true);
			bool bNewValue = OptionMenu_ButtonOptionsToggle("Subtitles", kMainMenuButtonPos, lY, msSelectedAudioButton, bValue, mlActionHorizontal);
			
			if(bValue != bNewValue)
			{
				mpConfig.SetBool("Sound", "ShowSubtitles", bNewValue);
			}
			
			msSelectedAudioButton = OptionMenu_UpdateFocus("Subtitles", msSelectedAudioButton);
			lY++;
		}

		
		/////////////////
		// HEARING AID
		{
			//////////////
			// Draw button and update config
			bool bValue = mpConfig.GetBool("Sound", "ForceShowSubtitleCharacterName", false);
			bool bNewValue = OptionMenu_ButtonOptionsToggle("HearingAid", kMainMenuButtonPos, lY, msSelectedAudioButton, bValue, mlActionHorizontal);
			
			if(bValue != bNewValue)
			{
				mpConfig.SetBool("Sound", "ForceShowSubtitleCharacterName", bNewValue);
			}
			
			msSelectedAudioButton = OptionMenu_UpdateFocus("HearingAid", msSelectedAudioButton);
			lY++;
		}

		/////////////////
		// Back
		{
			lY++;
			bool bButton = OptionMenu_ButtonOptions("Back", kMainMenuButtonPos, lY, msSelectedAudioButton);
			bool bGamepad = ImGui_ActionTriggered(eImGuiAction_Cancel, true);

			if(bButton || bGamepad)
			{
				ApplySettings();
				mCurrentGroup = eMainMenuGroup_Options;

				msFocusNextFrame = msSelectedOptionsButton;

				/////////
				// Reset menu position
				if(bGamepad == false)
				{
					OptionMenu_GamepadButtons(msSelectedAudioButton != "Back");
					msSelectedAudioButton = "Volume";
					return;
				}
			}

			msSelectedAudioButton = OptionMenu_UpdateFocus("Back", msSelectedAudioButton);
		}

		///////////
		// Show gamepad legacy
		OptionMenu_GamepadButtons(msSelectedAudioButton != "Back");
	}
	
	//------------------------------------------------------

	void GuiOptionsGameplay()
	{
		//////////////////////////////////////////////////
		// Check if extra width needed for translations
		{
			OptionMenu_UpdateExtraWidth("Language", false);
			OptionMenu_UpdateExtraWidth("ShowHints", true);
			OptionMenu_UpdateExtraWidth("ScreenDisortion", true);
			OptionMenu_UpdateExtraWidth("ColorSeparation", true);
			OptionMenu_UpdateExtraWidth("CrosshairSimple", true);
			OptionMenu_UpdateExtraButtonWidth_Toggle();
			OptionMenu_UpdateExtraButtonWidth_MultiSelection(mvLangFiles, "Languages");
		}
		
		////////////////////////////////////
		// Options background
		cVector2f vSize = kOptionsGameplayBgSize;
		
		////////////////
		// Gameplay
		OptionMenu_SectionTitle("Gameplay", kOptionsBgPos, kOptionsGameplayBgSize);
		
		ImGui_DrawFrame(mGfxFrame, OptionMenu_GetTopLeftOffset(kOptionsBgPos, 0.0), OptionMenu_GetScaledSize(vSize+cVector2f(OptionMenu_GetExtraWidth(), 0)));
		
		int lY = 0;

		/////////////////
		// LANGUAGE
		{
			//////////////
			// Draw button and update config
			tString sLang = cString_SetFileExt(mpConfig.GetString("Main", "StartLanguage", cLux_GetDefaultGameLanguage()), "");
			int lValue = 0;

			for(int i = 0; i < mvLangFiles.size(); ++i)
			{
				if(sLang == mvLangFiles[i])
				{
					lValue = i;
					break;
				}
			}

			int lNewValue = OptionMenu_ButtonOptionsMultiSelect("Language", kMainMenuButtonPos, lY++, msSelectedGameplayButton, mvLangFiles, lValue, false, mlActionHorizontal, "Languages");
			
			if(lValue != lNewValue)
			{
				// if set to russian, use large font
				tString sNewLang = mvLangFiles[lNewValue];
				mpConfig.SetBool("Sound", "UseLargeFont", (sNewLang == "russian" || sNewLang == "russian.lang"));
				
				mpConfig.SetString("Main", "StartLanguage", cString_SetFileExt(mvLangFiles[lNewValue], "lang"));
				mbHasSaveFiles = false; //update save file names
				ApplySettings();
			}

			msSelectedGameplayButton = OptionMenu_UpdateFocus("Language", msSelectedGameplayButton);
		}
		
		/////////////////
		// Hints
		{
			//////////////
			// Draw button and update config
			bool bValue = mpConfig.GetBool("Gameplay", "ShowHints", true);
			bool bNewValue = OptionMenu_ButtonOptionsToggle("ShowHints", kMainMenuButtonPos, lY++,
								msSelectedGameplayButton, bValue, mlActionHorizontal);
			
			if(bValue != bNewValue)
			{
				mpConfig.SetBool("Gameplay", "ShowHints", bNewValue);
			}
			
			msSelectedGameplayButton = OptionMenu_UpdateFocus("ShowHints", msSelectedGameplayButton);
		}

		/////////////////
		// Screen Distortion
		{
			//////////////
			// Draw button and update config
			bool bValue = mpConfig.GetBool("Gameplay", "ScreenDisortion", true);
			bool bNewValue = OptionMenu_ButtonOptionsToggle("ScreenDisortion", kMainMenuButtonPos, lY++,
								msSelectedGameplayButton, bValue, mlActionHorizontal);
			
			if(bValue != bNewValue)
			{
				mpConfig.SetBool("Gameplay", "ScreenDisortion", bNewValue);
			}
			
			msSelectedGameplayButton = OptionMenu_UpdateFocus("ScreenDisortion", msSelectedGameplayButton);
		}
		/////////////////
		// Color Separation
		{
			//////////////
			// Draw button and update config
			bool bValue = mpConfig.GetBool("Gameplay", "ColorSeparation", true);
			bool bNewValue = OptionMenu_ButtonOptionsToggle("ColorSeparation", kMainMenuButtonPos, lY++,
								msSelectedGameplayButton, bValue, mlActionHorizontal);
			
			if(bValue != bNewValue)
			{
				mpConfig.SetBool("Gameplay", "ColorSeparation", bNewValue);
			}
			
			msSelectedGameplayButton = OptionMenu_UpdateFocus("ColorSeparation", msSelectedGameplayButton);
		}

		/////////////////
		// Cursor Style
		{
			//////////////
			// Draw button and update config
			bool bValue = mpConfig.GetBool("Gameplay", "CrossHairStyleSimple", false);
			bool bNewValue = OptionMenu_ButtonOptionsToggle("CrosshairSimple", kMainMenuButtonPos, lY++, 
								msSelectedGameplayButton, bValue, mlActionHorizontal);
			
			if(bValue != bNewValue)
			{
				mpConfig.SetBool("Gameplay", "CrossHairStyleSimple", bNewValue);
				ApplySettings();
			}

			msSelectedGameplayButton = OptionMenu_UpdateFocus("CrosshairSimple", msSelectedGameplayButton);
		}

		/////////////////
		// Back
		{
			bool bButton = OptionMenu_ButtonOptions("Back", kMainMenuButtonPos, lY, msSelectedGameplayButton);
			bool bGamepad = ImGui_ActionTriggered(eImGuiAction_Cancel, true);

			if(bButton || bGamepad)
			{
				/////////////
				// Enable subtitles if other than english is selected
				tString sLang = mpConfig.GetString("Main", "StartLanguage", cLux_GetDefaultGameLanguage());
				if((sLang == "english" || sLang == "english.lang") == false)
				{
					mpConfig.SetBool("Sound", "ShowSubtitles", true);
				}

				ApplySettings();
				mCurrentGroup = eMainMenuGroup_Options;

				msFocusNextFrame = msSelectedOptionsButton;

				/////////
				// Reset menu position
				if(bGamepad == false)
				{
					OptionMenu_GamepadButtons(msSelectedGameplayButton != "Back");
					msSelectedGameplayButton = "Language";
					return;
				}
			}

			msSelectedGameplayButton = OptionMenu_UpdateFocus("Back", msSelectedGameplayButton);
		}

		///////////
		// Show gamepad legacy
		OptionMenu_GamepadButtons(msSelectedGameplayButton != "Back");
	}

	//------------------------------------------------------

	void ShowMessageBoxes()
	{
		if(mbShowApplyChanges )
		{
			MessageBoxApplyChanges();
		}
		else if(mbShowDuplicateKeys )
		{
			MessageBoxDuplicateKeys();
		}
		else if(mbShowApplyKeyChanges )
		{
			MessageBoxApplyKeyChanges();
		}
		else if(mbShowReset)
		{
			MessageBoxResetKeys();
		}
		else if(mfKeepDisplaySetting > 0)
		{
			MessageBoxKeepResolution();
		}
		else if(mlActionToBind > 0)
		{
			MessageBoxKeybind();
		}
		else if(mbShowRestartWarning)
		{
			MessageBoxRestartWarning();
		}
		else if(mbShowExit)
		{
			if(mbMainMenuActive)
			{
				MessageBoxExitFromMainMenu();
			}
			else
			{
				MessageBoxExitFromPauseMenu();
			}
		}
		else if(mbShowPlayGo)
		{
			MessageBoxPlayGo();
		}
		else if(mbShowNewGame)
		{
			MessageBoxNewGame();
		}
		else if(mbShowLoadGame)
		{
			MessageBoxLoadGame();
		}
		else if(msLoadSaveError.length() > 0)
		{
			MessageBoxLoadError();
		}
		else if(mbShowDetectSettings)
		{
			MessageBoxDetectSettings();
		}
	}

	void MessageBoxApplyChanges()
	{
		////////////////
		// Apply changes message box
		int lSelect = OptionMenu_MessageBox_Proper("ApplyChanges", "Yes", "No", msMessageBoxFocus, msMessageBoxFocus);
		ImGui_SetModUseInput(false); //disable input for any other widgets

		if(lSelect == -1)
		{
			ApplySettings();

			if(Platform_IsPS4())
			{
				mCurrentGroup = eMainMenuGroup_Options;
				msFocusNextFrame = msSelectedOptionsButton;
			}
			else
			{
				mCurrentGroup = eMainMenuGroup_Options_Video;
				msFocusNextFrame = msSelectedVideoButton;
			}

			mbShowRestartWarning = mbRestartWarning;
			mbShowApplyChanges = false;
			
			if(GetCurrentResolution() != mlCurrentResolution && Platform_IsPS4() == false)
			{
				////////////
				// If resolution has changed 
				mfKeepDisplaySetting = 15;
			}

			if(mfKeepDisplaySetting > 0) msFocusNextFrame = "No";
			else if(mbShowRestartWarning == false) msFocusNextFrame = msSelectedVideoButton;
			else if(mbShowRestartWarning) msFocusNextFrame = "Ok";
		}
		else if(lSelect == 1)
		{
			DiscardSettings();
			
			if(Platform_IsPS4())
			{
				mCurrentGroup = eMainMenuGroup_Options;
				msFocusNextFrame = msSelectedOptionsButton;
			}
			else
			{
				mCurrentGroup = eMainMenuGroup_Options_Video;
				msFocusNextFrame = msSelectedVideoButton;
			}

			mbShowApplyChanges = false;
		}

		///////////
		// Show gamepad legacy
		OptionMenu_GamepadButtons(true);
	}
	
	void MessageBoxApplyKeyChanges()
	{
		////////////////
		// Apply changes message box
		int lSelect = OptionMenu_MessageBox_Proper("ApplyChanges", "Yes", "No", msMessageBoxFocus, msMessageBoxFocus);
		ImGui_SetModUseInput(false); //disable input for any other widgets

		if(lSelect == -1)
		{
			ApplyKeybinds();

			mCurrentGroup = eMainMenuGroup_Options_Input;
			msFocusNextFrame = msSelectedInputButton;
			mbShowApplyKeyChanges = false;
		}
		else if(lSelect == 1)
		{
			DiscardKeybinds();

			mCurrentGroup = eMainMenuGroup_Options_Input;
			msFocusNextFrame = msSelectedInputButton;
			mbShowApplyKeyChanges = false;
		}

		///////////
		// Show gamepad legacy
		OptionMenu_GamepadButtons(true);
	}
	
	void MessageBoxDuplicateKeys()
	{
		////////////////
		// Apply changes message box
		int lSelect = OptionMenu_MessageBox_Proper("DuplicateKeys", "Yes", "No", msMessageBoxFocus, msMessageBoxFocus);
		ImGui_SetModUseInput(false); //disable input for any other widgets

		if(lSelect == -1)
		{
			msFocusNextFrame = "Yes";
			mbShowDuplicateKeys = false;
		}
		else if(lSelect == 1)
		{
			msFocusNextFrame = "Back";
			mbShowDuplicateKeys = false;
			mbShowApplyKeyChanges = false;
		}

		///////////
		// Show gamepad legacy
		OptionMenu_GamepadButtons(true);
	}
	
	void MessageBoxResetKeys()
	{
		////////////////
		// Apply changes message box
		int lSelect = OptionMenu_MessageBox_Proper("ResetToDefaultMessage", "Yes", "No", msMessageBoxFocus, msMessageBoxFocus);
		ImGui_SetModUseInput(false); //disable input for any other widgets

		if(lSelect == -1)
		{
			// Erase all settings
			if(mbBindingGamepad)
			{
				for(int i = 0; i < mvGamepadActions.size(); ++i)
				{
					mpKeyConfig.EraseValue(mvGamepadActions[i].msAction, "GamepadPrimary");
					mpKeyConfig.EraseValue(mvGamepadActions[i].msAction, "GamepadSecondary");
				}
			}
			else
			{
				for(int i = 0; i < mvActions.size(); ++i)
				{
					mpKeyConfig.EraseValue(mvActions[i].msAction, "Primary");
					mpKeyConfig.EraseValue(mvActions[i].msAction, "Secondary");
				}
			}

			// Get default settings by reloading key config
			cLux_GetInputHandler().LoadKeyConfig();

			mbKeybindChanged = true;
			msFocusNextFrame = "ResetToDefault";
			mbShowReset = false;
				
			/////////////
			// Reloading keys will make actions trigger again, so ignore next frame
			mlIgnoreInput = 3;
		}
		else if(lSelect == 1)
		{
			msFocusNextFrame = "ResetToDefault";
			mbShowReset = false;
		}

		///////////
		// Show gamepad legacy
		OptionMenu_GamepadButtons(true);
	}
	
	void MessageBoxRestartWarning()
	{
		//////////////
		// Restart warning message box
		int lSelect = OptionMenu_MessageBox_Proper("RestartRequired", "Ok", msMessageBoxFocus, msMessageBoxFocus);
		ImGui_SetModUseInput(false); //disable input for any other widgets
			
			
		if(lSelect == 1)
		{
			mbShowRestartWarning = false;
			msFocusNextFrame = msSelectedVideoButton;
		}

		///////////
		// Show gamepad legacy
		OptionMenu_GamepadButtons(false);
	}

	void MessageBoxKeepResolution()
	{
		//////////////
		// Restart warning message box
		int lSelect = OptionMenu_MessageBox_Proper("KeepSettings", "Yes", "No", msMessageBoxFocus, msMessageBoxFocus, cString_To16Char(""+cMath_RoundToInt(mfKeepDisplaySetting+0.5)));
		ImGui_SetModUseInput(false); //disable input for any other widgets
		
		mfKeepDisplaySetting -= 1.0 / 60.0;	

		if(lSelect == -1)
		{
			// Keep settings
			if(mbShowRestartWarning) msFocusNextFrame = "Ok";
			else msFocusNextFrame = msSelectedVideoButton;

			mfKeepDisplaySetting = 0;
		}
		else if(lSelect == 1 || mfKeepDisplaySetting <= 0)
		{
			//////////
			// Revert to old settings
			mpConfig.SetString("Screen", "FullScreen", msCurrentDisplayMode);
			SetCurrentResolution(mlCurrentResolution);
			ApplySettings();

			if(mbShowRestartWarning) msFocusNextFrame = "Ok";
			else msFocusNextFrame = msSelectedVideoButton;

			mfKeepDisplaySetting = 0;
		}

		///////////
		// Show gamepad legacy
		OptionMenu_GamepadButtons(false);
	}
	
	void MessageBoxPlayGo()
	{
		////////////////
		// Get time left
		int lETA = 0;
		cLux_IsPlayGoReady(lETA);

		int lSeconds = lETA % 60;
		int lMinutes = (lETA / 60) % 60;
		int lHour = (lETA / 3600);

		tString sTime;

		if(lHour > 9) sTime += lHour + ":";
		else if(lHour > 0) sTime += "0"+lHour + ":";
			
		if(lMinutes > 9) sTime += lMinutes + ":";
		else if(lMinutes > 0) sTime += "0"+lMinutes + ":";

		if(lSeconds > 9) sTime += lSeconds;
		else if(lSeconds > 0) sTime += "0"+lSeconds;

		if(lETA == 0)
		{
			mfPlayGoTimer -= 1.0f / 30.0f;
			sTime = "";
		}
		else
		{
			mfPlayGoTimer = 3.0f;
		}

		//////////////
		// Restart warning message box
		int lSelect = OptionMenu_MessageBox_Proper("PlayGoInstructions", "Ok", "", msMessageBoxFocus, msMessageBoxFocus, cString_To16Char(sTime));
		ImGui_SetModUseInput(false); //disable input for any other widgets
		
		if(lSelect == 1 || mfPlayGoTimer < 0)
		{
			mbShowPlayGo = false;
			msFocusNextFrame = msSelectedMainMenuButton;
		}

		///////////
		// Show gamepad legacy
		OptionMenu_GamepadButtons(false);
	}

	void MessageBoxKeybind()
	{
		////////////////////////////////////
		// Darken other widgets
		cImGuiGfx gfx;
		ImGui_DrawGfx(gfx, ImGui_NrmPos(0,0,24.5f), ImGui_NrmSize(2.0), cColor(0.0, 0.75));

		////////////////////////////////////
		// Options background
		ImGui_DrawFrame(mGfxFrame, OptionMenu_GetTopLeftOffset(kOptionsBgPos, 0.0), OptionMenu_GetScaledSize(kOptionMenu_KeybindBgSize));
		
		///////////////
		// Draw title
		cImGuiLabelData labelData;
		labelData.mFont.SetFile("sansation_large_bold.fnt");
		labelData.mFont.mvSize = cVector2f(36, 36);
		labelData.mFont.mColor = cColor(1,1);
		labelData.mFontAlign = eFontAlign_Center;
		
		//////////////
		// Get data based on bind type
		bool bAnalog = mbBindingGamepad ? mvGamepadActions[mlActionToBind-1].mbAnalog : mvActions[mlActionToBind-1].mbAnalog;
		tString sAction = mbBindingGamepad ? mvGamepadActions[mlActionToBind-1].msAction : mvActions[mlActionToBind-1].msAction;

		if(bAnalog)
		{
			tString sLabel = msKeybindFirstState.length() == 0 ? "PressRightGamepad" : "PressUpGamepad";

			ImGui_DoLabelExt(sLabel,labelData, OptionMenu_GetTopLeftOffset(kOptionMenu_KeybindBgPos + cVector2f(kOptionMenu_KeybindBgSize.x * 0.45,15), 5.5), 0);
		}
		else
		{
			ImGui_DoLabelExt("PressAnyKey",labelData, OptionMenu_GetTopLeftOffset(kOptionMenu_KeybindBgPos + cVector2f(kOptionMenu_KeybindBgSize.x * 0.45,15), 5.5), 0);
		}

		///////////
		// Show gamepad legacy
		OptionMenu_GamepadButtons(false);

		///////////////
		// Check if keybind button was pressed
		tString sKeyPressed = cLux_GetInputHandler().GetLatestKeyPressed();

		if(sKeyPressed.length() > 0)
		{
			/////////////
			// Disable cancel
			ImGui_ActionTriggered(eImGuiAction_Cancel, true);

			if(sKeyPressed != "Keyboard.Escape")
			{
				//////////////
				// Check for valid keys
				if(mbBindingGamepad)
				{
					// Only allow gamepad 0
					if(cString_GetFirstStringPos(sKeyPressed, "Gamepad.0") == -1)
					{
						return;
					}
				}
				else
				{
					// Only allow mouse or keyboard
					if(cString_GetFirstStringPos(sKeyPressed, "Gamepad") >= 0)
					{
						return;
					}
				}

				if(bAnalog)
				{
					/////////////////
					// Analog requires two binds in a row and must be from gamepad
					if(cString_GetFirstStringPos(sKeyPressed, "Gamepad") != -1 && 
					   cString_GetFirstStringPos(sKeyPressed, "Axis") != -1)
					{
						if(msKeybindFirstState.length() == 0) 
						{
							msKeybindFirstState = sKeyPressed;
							return;
						}
						else if(sKeyPressed != msKeybindFirstState)
						{
							sKeyPressed = msKeybindFirstState +"."+ ParseKeybind(sKeyPressed, false);
						}
						else
						{
							return; //Skip binding if its the same axis again
						}
					}
					else
					{
						return; //Skip binding if not a gamepad axis
					}
				}
				
								
				mpKeyConfig.SetString(sAction, msKeybindSlot, sKeyPressed);
				mbKeybindChanged = true;
				mlIgnoreInput = 3;
			}

			mlActionToBind = 0;
			msFocusNextFrame = msFocusAfterBind;
		}
	}

	void MessageBoxExitFromPauseMenu()
	{
		//////////////
		// Restart warning message box
		bool bExitToMenu = mpConfig.GetBool("Main", "ShowMenu", true);
		tString sMessageBoxText = "ExitNoSaveToMenuMessageBox";
		if(bExitToMenu)
		{
			if(mbSaveAndExit)
				sMessageBoxText = "ExitToMenuMessageBox";
		}
		else
		{
			if(mbSaveAndExit)
				sMessageBoxText = "ExitMessageBox";
		}
		int lSelect = OptionMenu_MessageBox_Proper(sMessageBoxText, "Yes", "No", msMessageBoxFocus, msMessageBoxFocus);
		ImGui_SetModUseInput(false); //disable input for any other widgets

		if(lSelect == 1)
		{
			///////////
			// Cancel
			if(mbSaveAndExit)
				msFocusNextFrame = "SaveAndExit";
			else
				msFocusNextFrame = "Exit";
			
			mbShowExit = false;
			mbSaveAndExit = false;
			
		}
		else if(lSelect == -1)
		{
			///////////
			// Check for exit to menu or exit game
			if(bExitToMenu)
			{
				//mbMenuActive = false; 
				LoadScreen_SetUseSmallIcon(false);
				cLux_GetGuiHandler().SetGameHudInputFocus(false);

				if(mbSaveAndExit && Map_IsChanging() == false)
				{
					Game_AutoSave(false, false);
				}
				
				ImGui_AddTimer("ExitToMainMenu", mfFadeLength);
				Map_FadeOut(mfFadeLength);
				Music_StopAll(mfFadeLength);
				Sound_Stop("MenuBGNoise", mfFadeLength);
			}
			else
			{
				if(mbSaveAndExit && Map_IsChanging() == false)
				{
					Game_AutoSave(false, false);
				}

				//mbMenuActive = false; 
				//if(mpConfig.GetBool("Main", "ShowMenu", true) == false) cLux_Exit();
				
				ImGui_AddTimer("ExitGame", mfExitGameFadeLength);
				Map_FadeOut(mfExitGameFadeLength);
				Music_StopAll(mfExitGameFadeLength);
				Sound_Stop("MenuBGNoise", mfFadeLength);
			}
						
			return;
		}
	}
	
	void MessageBoxExitFromMainMenu()
	{
		//////////////
		// Restart warning message box
		int lSelect = OptionMenu_MessageBox_Proper("ExitMessageBox", "Yes", "No", msMessageBoxFocus, msMessageBoxFocus);
		ImGui_SetModUseInput(false); //disable input for any other widgets

		if(lSelect == 1)
		{
			///////////
			// Cancel
			mbShowExit = false;
			mbSaveAndExit = false;
			msFocusNextFrame = "Exit";
		}
		else if(lSelect == -1)
		{
			///////////
			// Exit the game
			//SetMenuActive(false);
			//cLux_Exit();
			
			cLux_GetGuiHandler().SetGameHudInputFocus(false);
			
			ImGui_AddTimer("ExitGame", mfExitGameFadeLength);
			Map_FadeOut(mfExitGameFadeLength);
			Music_StopAll(mfExitGameFadeLength);
			Sound_Stop("MenuBGNoise", mfExitGameFadeLength);
			
			return;
		}
	}

	void MessageBoxNewGame()
	{
		//////////////
		// Restart warning message box
		int lSelect = OptionMenu_MessageBox_Proper("OverwriteGame", "Yes", "No", msMessageBoxFocus, msMessageBoxFocus);

		if(lSelect == 1)
		{
			///////////
			// Cancel
			mbShowNewGame = false;
			msFocusNextFrame = "NewGame";
		}
		else if(lSelect == -1)
		{
			///////////
			// Load the game
			ClickNewGame();
			
			cLux_GetGuiHandler().SetGameHudInputFocus(false);
			return;
		}
	}

	void MessageBoxLoadGame()
	{
		//////////////
		// Restart warning message box
		int lSelect = OptionMenu_MessageBox_Proper("LoadMessageBox", "Yes", "No", msMessageBoxFocus, msMessageBoxFocus);
		ImGui_SetModUseInput(false); //disable input for any other widgets

		if(lSelect == 1)
		{
			///////////
			// Cancel
			mbShowLoadGame = false;
				
			if(mCurrentGroup == eMainMenuGroup_LoadGame)
			{
				if(mlSelectedLoadButton >= 0 && mlSelectedLoadButton < 10) msFocusNextFrame = "Save"+mlSelectedLoadButton;
				else													   msFocusNextFrame = "Back";
			}
			else
			{
				msFocusNextFrame = "Continue";
			}
		}
		else if(lSelect == -1)
		{
			///////////
			// Load the game
			ImGui_AddTimer("LoadGame", mfFadeLength);
			cSound_FadeOutAll(eSoundEntryType_WorldAll, 1.0f / mfFadeLength, false);
			Music_StopAll(mfFadeLength);
			Sound_Stop("MenuBGNoise", mfFadeLength);
			mbShowLoadGame = false;
			cLux_GetGuiHandler().SetGameHudInputFocus(false);
			return;
		}

		///////////
		// Show gamepad legacy
		OptionMenu_GamepadButtons(false);
	}

	void MessageBoxLoadError()
	{
		//////////////
		// Restart warning message box
		ImGui_SetTransCategory("LoadGame");
		int lSelect = OptionMenu_MessageBox_Proper(msLoadSaveError, "Ok", "", msMessageBoxFocus, msMessageBoxFocus, ImGui_Translate(mbProfileError ? "DeleteProfile" : "DeleteSave"));
		ImGui_SetModUseInput(false); //disable input for any other widgets
		ImGui_SetTransCategory("Menu");

		if(lSelect == 1)
		{
			msLoadSaveError = "";

			if(mbProfileError == false && cString_To8Char(msPreviousSaveLoaded) != "")
			{
				//////////////////
				//Delete the save file
				cLux_GetSaveHandler().DeleteSaveFile(msPreviousSaveLoaded);

				for(int i = 0; i < mvSaveFiles.size(); ++i)
				{
					if(cString_To8Char(mvSaveFiles[i]) == 
					   cString_To8Char(msPreviousSaveLoaded))
					{
						for(int j = i + 1; j < mvSaveFiles.size(); ++j)
						{
							mvSaveFiles[j-1] = mvSaveFiles[j];
							mvSaveDates[j-1] = mvSaveDates[j];
							mvSaveNames[j-1] = mvSaveNames[j];	
						}
						
						mvSaveFiles.resize(mvSaveFiles.size()-1);
						mvSaveDates.resize(mvSaveDates.size()-1);
						mvSaveNames.resize(mvSaveNames.size()-1);

						break;
					}
				}

				if(cString_To8Char(msContinueFile) == cString_To8Char(msPreviousSaveLoaded)) msContinueFile = "";
				msPreviousSaveLoaded = "";

				mbCanContinue = mvSaveFiles.size() > 0;

				if(mbCanContinue)
				{
					msContinueFile = mvSaveFiles[0]; 

					///////////
					// Remove "CheckPoint" from save file list
					for(int i = 0; i < mvSaveFiles.size(); ++i)
					{
						if(mvSaveNames[i] == tWString("CheckPoint"))
						{
							for(int j = i + 1; j < mvSaveFiles.size(); ++j)
							{
								mvSaveFiles[j-1] = mvSaveFiles[j];
								mvSaveDates[j-1] = mvSaveDates[j];
								mvSaveNames[j-1] = mvSaveNames[j];	
							}
						
							mvSaveFiles.resize(mvSaveFiles.size()-1);
							mvSaveDates.resize(mvSaveDates.size()-1);
							mvSaveNames.resize(mvSaveNames.size()-1);

							break;
						}
					}
				}
			}
		}

		///////////
		// Show gamepad legacy
		if(mbProfileError == false) OptionMenu_GamepadButtons(false);
	}
	
	void MessageBoxDetectSettings()
	{
		////////////////
		// Apply changes message box
		int lSelect = OptionMenu_MessageBox_Proper("DetectSettingsPrompt", "Yes", "No", msMessageBoxFocus, msMessageBoxFocus);
		ImGui_SetModUseInput(false); //disable input for any other widgets

		if(lSelect == -1)
		{
			AutoDetectSettings(false);
			mbShowDetectSettings = false;
		}
		else if(lSelect == 1)
		{
			mbShowDetectSettings = false;
		}

		///////////
		// Show gamepad legacy
		OptionMenu_GamepadButtons(true);
	}
	
	//------------------------------------------------------

	void GuiGammaCorrection()
	{
		array<tString> vSpeakerValues = {"SmallTV", "MediumTV", "HomeCinema", "Headphones", "RemotePlay", "NightMode"};
		OptionMenu_UpdateExtraWidth("Gamma", false);
		if (Platform_IsPS4() && mbPremenuActive)
		{
			OptionMenu_UpdateExtraWidth("SpeakerType", false);
			OptionMenu_UpdateExtraButtonWidth_MultiSelection(vSpeakerValues);
		}
			
		/////////////
		// Accept pressed
		bool bAccept = ImGui_ActionTriggered(eImGuiAction_Confirm, true);
		bool bCancelled = ImGui_ActionTriggered(eImGuiAction_Cancel, true);

		/////////////
		// Setup
		cVector2f vAspect = cGraphics_GetLowLevel().GetScreenSizeFloat();
		float fAspect = vAspect.x/vAspect.y;
		if(fAspect>=3.75f)
			fAspect/=3.0f;
			
		float fAspectCorrection = 0.5625 * fAspect;
		
		cGuiSet@ pSet = cLux_GetCurrentImGui().GetSet();
		cVector2f vSize = pSet.GetVirtualSize();

		bool bShowAcceptOnly = mbPremenuActive;
		
		float fAlpha = mbPremenuActive ? mfPreMenuFadeAmount : 1;
		OptionMenu_SetModColor(cColor(1, fAlpha));
		
		/////////////////////////////////////
		// Background
		cImGuiGfx gfx("gamma_background.tga", eImGuiGfx_Texture);
		cVector2f vBgSize = OptionMenu_GetScaledSize(cVector2f(1280, 720) * 0.67) * cVector2f(fAspectCorrection);
		cVector3f vBgPos = OptionMenu_GetCenterOffset(cVector2f(0), 5.2) - cVector3f(vBgSize.x * 0.5, vBgSize.y * 0.75, 0.0);
		ImGui_DrawGfx(gfx, vBgPos, vBgSize, cColor(1, fAlpha));

		/////////////////////
		// Help text
		{
			cImGuiTextFrameData frameData;
			frameData.mFont.SetFile("sansation_large_bold.fnt");
			frameData.mFont.mvSize = cVector2f(24, 24);
			frameData.mFont.mColor = cColor(1,fAlpha);
			frameData.mbUseBackgroundGfx = false;
			frameData.mFontAlign = eFontAlign_Left;

			ImGui_DoTextFrameExt("GammaInstructions0", cVector2f(0), 2.0, 0.0, frameData, OptionMenu_GetCenterOffset(cVector2f(0), 5.3) + cVector3f(vBgSize.x *-0.5, vBgSize.y * 0.17, 0), vBgSize);
		}

		////////////////
		// Setup variables
		float fOffsetX = (vBgPos.x - OptionMenu_GetTopLeftOffset(kMainMenuButtonPos, 0.0f).x) * vAspect.x / vAspect.y * 720 / vSize.x; 
		
		int lY = 5;
		
		////////////////
		// Slider
		{
			float fValue = (mpConfig.GetFloat("Graphics", "Brightness", 1.0f) - 0.3f) / (2.0f - 0.6f);
			float fNewValue = OptionMenu_ButtonOptionsSlider("Gamma", kMainMenuButtonPos + cVector2f(fOffsetX, 20), lY++, msSelectedGammaButton, fValue, 0.05f, mlActionHorizontal, "");

			if(fNewValue != fValue)
			{
				mpConfig.SetFloat("Graphics", "Brightness", (fNewValue * (2.0f - 0.6f) + 0.3f));
				cGraphics_GetLowLevel().SetBrightness((fNewValue * (2.0f - 0.6f) + 0.3f));
				mlOptionChanges++;
			}

			msSelectedGammaButton = OptionMenu_UpdateFocus("Gamma", msSelectedGammaButton);
		}
		
		////////////////
		// Speaker type
		if(Platform_IsPS4() && mbPremenuActive)
		{
			/////////////
			// Draw multi select box and update config
			tString sValue = mpConfig.GetString("Sound", "SpeakerType", "HomeCinema");
			int lValue =-1;
			for(int i=0;i<vSpeakerValues.size(); ++i)
			{
				if(sValue == vSpeakerValues[i]){
					lValue = i;
					break;
				}
			}
			
			int lNewValue = OptionMenu_ButtonOptionsMultiSelect("SpeakerType", kMainMenuButtonPos + cVector2f(fOffsetX, 20), lY++, msSelectedGammaButton, vSpeakerValues, lValue, false, mlActionHorizontal);
			
			if(lValue != lNewValue)
			{
				mpConfig.SetString("Sound", "SpeakerType", vSpeakerValues[lNewValue]);
				ApplySettings(false);
			}

			msSelectedGammaButton = OptionMenu_UpdateFocus("SpeakerType", msSelectedGammaButton);
		}

		//////////////
		// Accept button
		{
			if(OptionMenu_ButtonOptions(bShowAcceptOnly ? "AcceptGamma" : "Back", kMainMenuButtonPos + cVector2f(fOffsetX, 20), lY, msSelectedGammaButton) || 
			   (bAccept && bShowAcceptOnly) || (bCancelled && bShowAcceptOnly == false))
			{
				if(bShowAcceptOnly)
				{		
					// Apply directly
					msFocusNextFrame = msSelectedMainMenuButton;
					
					if(mbFirstGameStart)
					{
						//////////////
						// Auto detect settings
						AutoDetectSettings(true);
						mbFirstGameStart = false;
						mpConfig.SetBool("Main", "FirstGameStart", mbFirstGameStart);
					}

					ApplySettings();
					
					
					/*
					mbPremenuActive = false;
					mbBackgroundShowFace = true;
					mbBackgroundShowTitle = true;*/
					mfPreMenuFadeDest=0;
				}
				else
				{
					if(mlOptionChanges == mlCurrentOptionChange)
					{
						// No changes
						msFocusNextFrame = msSelectedVideoButton;
					
						if(Platform_IsPS4())
						{
							mCurrentGroup = eMainMenuGroup_Options;
						}
						else
						{
							mCurrentGroup = eMainMenuGroup_Options_Video;
						}
					}
					else
					{
						/////////////
						// Show apply popup
						mbShowApplyChanges = true;
						msFocusNextFrame = "NO";
					}
				}
				
				mbShowingGammaMenu = false;
			}

			msSelectedGammaButton = OptionMenu_UpdateFocus(bShowAcceptOnly ? "AcceptGamma" : "Back", msSelectedGammaButton);
		}

		///////////
		// Show gamepad legacy
		fOffsetX = (vBgPos.x - OptionMenu_GetTopLeftOffset(cVector2f(140, 0),0).x) * vAspect.x / vAspect.y * 720 / vSize.x; 
		if (!mbShowApplyChanges)
			OptionMenu_GamepadButtons(true, false, cVector2f(fOffsetX, 0));
		
		OptionMenu_SetModColor(cColor(1, 1));
	}
	
	//------------------------------------------------------
	
	void GuiPreMenu(float afTimeStep)
	{
		///////////////////////
		// Init
		if(mbInitPreMenu)
		{
			mbInitPreMenu = false;
			mfPreMenuFadeAmount=1;
			mfPreMenuFadeDest=0;
			
			mlPreMenuState=-1;
			
			mbBackgroundShowTitle = false;
			mbBackgroundShowFace = false;
		}
		
		///////////////////////
		// Fade in/out
		if(mfPreMenuFadeAmount<1 && mfPreMenuFadeDest<1)
			ImGui_SetModUseInput(false);
		
		float fMul = mfPreMenuFadeDest>0 ? 	(mlPreMenuState==0 ? 0.4f : 1.0f) : 
											(mlPreMenuState==2 ? 1.0f : 0.5f);
		mfPreMenuFadeAmount	= cMath_IncreaseTo(mfPreMenuFadeAmount, afTimeStep*fMul, mfPreMenuFadeDest);
		if(mfPreMenuFadeAmount==0 && mfPreMenuFadeDest==0)
		{
			mlPreMenuState++;
			mfPreMenuFadeDest =1;
			
			if(mlPreMenuState==0)
			{
				ImGui_AddTimer("FGLogoOver", 3);
				Sound_PlayGui("special_fx/frontend/FG_Menu_Sting", 1.0f, eSoundEntryType_Gui);
				Music_PlayExt("IngameMenu_Music", true, 0.45f, 0.8f, 6.0f, 0.0f, eMusicPrio_OverrideAll, false);
				//Sound_CreateAtEntity("MenuBGNoise", "special_fx/frontend/main_menu_bg", "Player", 6.0f, false, 1.0f);
			}
			
			if(mlPreMenuState==1)
			{
				mbMouseVisible = true;
								
				if(mbShowPressX)
				{
					mbBackgroundShowFace = true;
					Music_PlayExt("IngameMenu_Music", true, 0.35f, 0.8f, 3.0f, 0.0f, eMusicPrio_OverrideAll, false);
					
					//Sound_CreateAtEntity("MenuBGNoise", "special_fx/frontend/main_menu_bg", "Player", 6.0f, false, 1.0f);
				}
				else
					mlPreMenuState++;
			}
			
			if(mlPreMenuState==2)
			{
				if(mbFirstGameStart && mbShowPreMenu)
				{
					Music_PlayExt("IngameMenu_Music", true, 0.35f, 0.8f, 6.0f, 0.0f, eMusicPrio_OverrideAll, false);
					mbBackgroundShowFace = true;
					
					//Sound_CreateAtEntity("MenuBGNoise", "special_fx/frontend/main_menu_bg", "Player", 6.0f, false, 1.0f);
				}
				else
				{
					msFocusNextFrame = msSelectedMainMenuButton;
					mbPremenuActive = false;
					mbBackgroundShowFace = true;
					mbBackgroundShowTitle = true;
                    
                    if(mCurrentBGPhase == eMainMenuPhase_AfterEnd)
                    {
                        Music_PlayExt("Completion_MenuMusic", true, mfMenuCompMusicVol, 1.0f, 6.0f, 0.0f, eMusicPrio_OverrideAll, false);
                        //Sound_CreateAtEntity("MenuBGNoise", "special_fx/frontend/main_menu_bg", "Player", 6.0f, false, 0.75f);
                    }
                    else
                    {
                        Music_PlayExt("Menu_Music", true, mfMenuMusicVol, 1.0f, 6.0f, 0.0f, eMusicPrio_OverrideAll, false);
                        //Sound_CreateAtEntity("MenuBGNoise", "special_fx/frontend/main_menu_bg", "Player", 6.0f, false, 1.0f);
                    }
					
					return;//So we do not show the gamma setup!
				}
			}
			
			if(mlPreMenuState==3)
			{
				msFocusNextFrame = msSelectedMainMenuButton;
				mbPremenuActive = false;
				mbBackgroundShowFace = true;
				mbBackgroundShowTitle = true;
                
                if(mCurrentBGPhase == eMainMenuPhase_AfterEnd)
                {
                    Music_PlayExt("Completion_MenuMusic", true, mfMenuCompMusicVol, 1.0f, 6.0f, 0.0f, eMusicPrio_OverrideAll, false);
                    //Sound_CreateAtEntity("MenuBGNoise", "special_fx/frontend/main_menu_bg", "Player", 6.0f, false, 0.75f);
                }
                else
                {
                    Music_PlayExt("Menu_Music", true, mfMenuMusicVol, 1.0f, 6.0f, 0.0f, eMusicPrio_OverrideAll, false);
                    //Sound_CreateAtEntity("MenuBGNoise", "special_fx/frontend/main_menu_bg", "Player", 6.0f, false, 1.0f);
                }
			}
		}
		
		///////////////////////
		// Black screen
		if(mlPreMenuState==-1)
		{
			cImGuiGfx gfxBlack;
			ImGui_DrawGfx(gfxBlack, ImGui_NrmPos(0,0,20.1f), ImGui_NrmSize(1.0), cColor(0,mfPreMenuFadeAmount));
		}
		///////////////////////
		// FG Logo
		if(mlPreMenuState==0)
		{
			cImGuiGfx gfx("frictional_games_logo.dds", eImGuiGfx_Texture);
			cVector2f vBgSize = OptionMenu_GetScaledSize(cVector2f(1024, 351) * 0.87);
			cVector3f vBgPos = OptionMenu_GetCenterOffset(cVector2f(0), 10.2) - cVector3f(vBgSize.x * 0.5, vBgSize.y * 0.5, 0.0);
			ImGui_DrawGfx(gfx, vBgPos, vBgSize, cColor(1, mfPreMenuFadeAmount));
			
			if(ImGui_TimerOver("FGLogoOver"))
			{
				mfPreMenuFadeDest =0;
			}
		}
		///////////////////////
		// FG Logo
		else if(mlPreMenuState==1)
		{
			GuiPressX();
		}
		///////////////////////
		// Gamma
		else if(mlPreMenuState==2)
		{
			// Show profile save error
			if(msLoadSaveError.length() > 0)
			{
				MessageBoxLoadError();
				ImGui_SetModUseInput(false); 
			}

			GuiGammaCorrection();		
		}
		
	}
	
	//------------------------------------------------------
		
	void GuiPressX()
	{
		cImGuiLabelData labelData;
		labelData.mFont.SetFile("sansation_xlarge_bold.fnt");
		labelData.mFont.mvSize = cVector2f(46, 46);
		labelData.mFont.mColor = cColor(1, mfPreMenuFadeAmount);

		ImGui_DoLabelExt("PressX",labelData, OptionMenu_GetTopLeftOffset(kOptionMenu_PressXPos, 1.0));

		////////////
		// Wait for keypress
		tString sKeyPressed = cLux_GetInputHandler().GetLatestKeyPressed();

		if(sKeyPressed.length() > 0)
		{
			int lPos = cString_GetFirstStringPos(sKeyPressed, "Gamepad");
			int lEndPos = cString_GetFirstStringPos(sKeyPressed, "Button.0");
			if(lPos != -1 && lEndPos != -1)
			{
				/////////////////
				// Get the device id from the gamepad that pressed the button
				tString sNum = cString_Sub(sKeyPressed, 8);
				int lDotPos = cString_GetFirstCharPos(sNum, '.');
				int lNum = cString_ToInt(cString_Sub(sNum, 0, lDotPos), 0 );

				/////////////
				// Set that gamepad as the primary one
				cLux_GetInputHandler().SetPrimaryGamepad(lNum);

				mfPreMenuFadeDest=0;
			}
		}
	}

	//------------------------------------------------------
	
	void ApplySettings(bool abSave = true)
	{
		/////////////
		// Saves the config
		if(abSave && cLux_GetSaveConfigAtExit()) mpConfig.Save();

		/////////////
		// Applies the changes to the engine and displays a message box if restart is needed
		mbRestartWarning = cLux_ApplyUserConfig();
	}

	void DiscardSettings()
	{
		///////////
		// Load settings
		mpConfig.Load();

		cGraphics_GetLowLevel().SetBrightness(mpConfig.GetFloat("Graphics", "Brightness", 1.0));
	}

	//------------------------------------------------------
	
	void ApplyKeybinds()
	{
		/////////////
		// Saves the config
		mpKeyConfig.Save();

		cLux_GetInputHandler().LoadKeyConfig();

		/////////////
		// Reloading keys will make actions trigger again, so ignore next frame
		mlIgnoreInput = 3;
		mbKeybindChanged = false;
	}

	void DiscardKeybinds()
	{
		///////////
		// Load settings
		mpKeyConfig.Load();
		mbKeybindChanged = false;
	}
	
	//------------------------------------------------------------
	
	void OnDraw(float afFrameTime)
	{
		
	}
	void OnPostRender(float afFrameTime)
	{
	
	}
	
	//------------------------------------------------------------
	
	/////////////////////////////////////////
	// ACTIONS
	/////////////////////////////////////////
	
	//------------------------------------------------------------
	
	void OnAction(int alAction, bool abPressed)
	{
		if(abPressed)
		{
			if(alAction == eAction_OpenMenu && LoadScreen_IsVisible() == false)
			{
				if(mbMenuActive == false && mbPauseMenuEnabled)
				{
					mbMainMenuActive = false;
					SetMenuActive(true);
				}
				else
				{
					mbMenuButtonPressed = true;
				}
			}
		}

		// Block all input
	}


	void OnAnalogInput(int alAnalogId, const cVector3f &in avAmount)
	{
	
	}
	
	//------------------------------------------------------------
	
	void OnExitPressed()
	{
	
	}
	
	//------------------------------------------------------------
	
	void AppGotInputFocus()
	{
	
	}
	void AppLostInputFocus()
	{
	
	}
	
	/////////////////////////////////////////
	// GLOBAL
	/////////////////////////////////////////
	
	//------------------------------------------------------------
		
	bool mbMainMenuActive = false;
	bool mbMenuActive = false;
	bool mbPauseMenuEnabled = true;
	bool mbMenuButtonPressed = false;
	bool mbCanContinue = false;
	bool mbGameOver = false;
	bool mbSaveLoadEnabled = true;
	
	//------------------------------------------------------------
		 
	bool mbRestartWarning = false;
	bool mbShowRestartWarning = false;
	bool mbShowApplyChanges = false;
	bool mbShowExit = false;
	bool mbShowPlayGo = false;
	bool mbShowNewGame = false;
	bool mbShowLoadGame = false;
	bool mbShowApplyKeyChanges = false;
	bool mbShowPreMenu = false;
	bool mbPremenuActive=false;
	bool mbFirstGameStart = false;
	bool mbShowReset = false;
	bool mbShowDuplicateKeys = false;
	bool mbShowPressX = false;
	float mfKeepDisplaySetting = 0.0f;
	bool mbShowDetectSettings = false;
	
	bool mbSaveAndExit = false;
	
	float mfPlayGoTimer = 0.0f;
	
	cImGuiFrameGfx mGfxFrame;
	//cImGuiWindowData mWindowData;
	
	tString msMessageBoxFocus = "No";
	
	[volatile] cConfigFile@ mpConfig;
	[volatile] cConfigFile@ mpKeyConfig;

	int mlActionHorizontal;
		
	int mlClickedPauseMenuButton;
	int mlClickedMainMenuButton;

	int mlCurrentResolution;
	tString msCurrentDisplayMode;

	tString msSelectedMainMenuButton;
	tString msSelectedStartButton;
	tString msSelectedPauseMenuButton;
	tString msSelectedOptionsButton;
	tString msSelectedGammaButton;
	tString msSelectedInputButton;
	tString msSelectedInputMouseButton;
	tString msSelectedInputGamepadButton;
	tString msSelectedInputMappingButton;
	tString msSelectedVideoButton;
	tString msSelectedVideoDisplayButton;
	tString msSelectedVideoPostEffectButton;
	tString msSelectedVideoWorldButton;
	tString msSelectedVideoGammaButton;
	tString msSelectedAudioButton;
	tString msSelectedGameplayButton;
	int mlSelectedLoadButton = 0;
	int mlSelectedKeybindButton = 0;
	
	bool mbBackgroundTitleSounds =true;
	bool mbBackgroundShowTitle =true;
	bool mbBackgroundShowFace =true;
	float mfBackgroundTitleAlpha=0;
	float mfBackgroundFaceAlpha=0;
	
	float mfMainAlpha=1;
	
	bool mbMouseVisible=true;
	
	int mlPreMenuState=0;
	bool mbInitPreMenu = true;
	float mfPreMenuFadeAmount=0;
	float mfPreMenuFadeDest=0;

	int mlOptionChanges = 0;
	int mlCurrentOptionChange;

	float mfFadeOut = 0.0f;
	float mfFadeIn = 0.0f;
	
	float mfFadeLength = 0.5f;
	float mfExitGameFadeLength = 1.0f;

	tString msFocusNextFrame;

	eMainMenuGroup mCurrentGroup;

	cVector2f mvAspectRatio;
	cVector2f mvSize;
	cVector2f mvOffset;
	
	array<cVector2l> mvResolutionSizes;
	array<tString> mvResolutionValues;
	array<int> mvRefresh;
	array<tString> mvRefreshValues;
	int mlSelectedResolution;

	array<tWString> mvSaveNames;
	array<tString> mvSaveDates;
	array<tWString> mvSaveFiles;
	bool mbHasSaveFiles = false;
	int mlSaveFileOffset=0;
	int mlSaveFileToLoad=0;
	bool mbScrollingSaveList=false;
	tString msLoadSaveError;
	bool mbProfileError;
	tWString msPreviousSaveLoaded;
	tWString msContinueFile;

	array<tString> mvLangFiles;

	float mfDisableEscapeCount = 1.0;
	
	////////////////
	// Keybinding
	array<cBindableAction> mvActions;
	array<cBindableAction> mvGamepadActions;
	int mlActionToBind=0;
	tString msKeybindSlot = "Primary";
	bool mbScrollingKeybindList=false;
	int mlKeybindOffset=0;
	int mlKeybindFocusSlot = 0;
	tString msFocusAfterBind;
	bool mbKeybindChanged;
	int mlIgnoreInput = 0;
	tString msKeybindFirstState;
	bool mbBindingGamepad = false;

	bool mbInitiated = false;
	
	//------------------------------------------------------------
}
